import{initializeApp as e}from"https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";import{getFirestore as t,doc as a,setDoc as r,getDoc as s,getDocs as o,deleteDoc as i,collection as n,updateDoc as c,query as d,where as l,orderBy as u,arrayUnion as h,increment as g,addDoc as m}from"https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";import{getAuth as y,signInWithPopup as w,signOut as p,GoogleAuthProvider as f,onAuthStateChanged as k}from"https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";const b=e({apiKey:"AIzaSyAGcg43F94bWqUuyLH-AjghrAfduEVQ8ZM",authDomain:"overunder-ths.firebaseapp.com",projectId:"overunder-ths",storageBucket:"overunder-ths.firebasestorage.app",messagingSenderId:"690530120785",appId:"1:690530120785:web:36dc297cb517ac76cb7470",measurementId:"G-Q30T39R8VY"}),I=t(b),v=y(b),U=new f,S=Object.freeze(["joelmulonde81@gmail.com","jordan.herrera@crpusd.org","kaidenchatigny@gmail.com","captrojolmao@gmail.com"]);function M(){const e=v.currentUser;if(!e)throw new Error("UNAUTHORIZED: No user signed in");if(!e.email||!S.includes(e.email.toLowerCase()))throw new Error("UNAUTHORIZED: Admin access required");return!0}const E=n(I,"mulon"),A=n(I,"mulon_orders"),C=n(I,"mulon_trades"),D=n(I,"mulon_positions"),_=n(I,"mulon_users"),O=n(I,"mulon_categories"),N=n(I,"mulon_suggestions"),B=n(I,"users"),R=n(I,"admin_edits"),L=n(I,"mulon_banned_devices"),P=n(I,"mulon_banned_emails"),x=n(I,"mulon_waitlist"),T=!0;async function F(e,t){if(t&&S.includes(t.toLowerCase()))return{approved:!0,isAdmin:!0};try{if((await s(a(_,e))).exists())return{approved:!0,isExistingUser:!0};const t=await s(a(x,e));if(!t.exists())return{approved:!1,status:"not_on_list"};const r=t.data();return"approved"===r.status?{approved:!0}:"rejected"===r.status?{approved:!1,status:"rejected"}:{approved:!1,status:"pending"}}catch(e){return console.error("Waitlist check error:",e),{approved:!0,error:!0}}}async function W(e,t={}){try{const a=v.currentUser;if(!a)return;const r={adminEmail:a.email,adminUid:a.uid,actionType:e,timestamp:(new Date).toISOString(),...t};await m(R,r),console.log("Admin action logged:",e)}catch(e){console.error("Error logging admin action:",e)}}function K(){let e=0;const t=[navigator.userAgent,navigator.language,screen.width+"x"+screen.height,screen.colorDepth,(new Date).getTimezoneOffset(),navigator.hardwareConcurrency||"unknown",navigator.platform].join("|");for(let a=0;a<t.length;a++){e=(e<<5)-e+t.charCodeAt(a),e&=e}let a=localStorage.getItem("mulon_device_id");return a||(a="dev_"+Date.now()+"_"+Math.random().toString(36).substring(2,15),localStorage.setItem("mulon_device_id",a)),a+"_"+Math.abs(e).toString(36)}window.checkWaitlistAccess=F,window.WAITLIST_ENABLED=T,window.checkBanStatus=async function(){try{const e=v.currentUser,t=K();if((await s(a(L,t))).exists())return console.log("Device is banned, redirecting..."),window.location.href="https://parismou.org/PMoU-Procedures/Library/banning",!0;if(e){if(e.email){const t=e.email.toLowerCase().replace(/[.#$[\]]/g,"_");if((await s(a(P,t))).exists())return console.log("Email is banned, redirecting..."),window.location.href="https://parismou.org/PMoU-Procedures/Library/banning",!0}const r=await s(a(_,e.uid));if(r.exists()&&!0===r.data().banned)return console.log("User is banned, redirecting..."),window.location.href="https://parismou.org/PMoU-Procedures/Library/banning",!0;await c(a(_,e.uid),{deviceFingerprints:h(t)}).catch((()=>{}))}return!1}catch(e){return console.error("Error checking ban status:",e),!1}},window.generateDeviceFingerprint=K;const j={async checkForOverUnderAccount(e){if(!e)return null;try{const t=d(B,l("email","==",e)),a=await o(t);if(!a.empty){const e=a.docs[0],t=e.data();return{found:!0,uid:e.id,username:t.username||null,name:t.name||null,email:t.email}}return{found:!1}}catch(e){return console.error("Error checking Over Under account:",e),{found:!1,error:e.message}}},async syncUsername(e,t){try{return await c(a(_,e),{displayName:t,overUnderSynced:!0}),{success:!0}}catch(e){return console.error("Error syncing username:",e),{success:!1,error:e.message}}}};window.OverUnderSync=j;const z={currentUser:null,authStateListeners:[],waitlistCheckPending:!1,init(){k(v,(async e=>{if(e){const t=window.location.pathname.includes("waitlist.html"),a=window.location.pathname.includes("admin.html")||window.location.pathname.includes("wdhn.html");if(!this.waitlistCheckPending&&!t&&!a){this.waitlistCheckPending=!0;const t=await F(e.uid,e.email);if(this.waitlistCheckPending=!1,!t.approved)return console.log("User not on approved waitlist, redirecting..."),void(window.location.href="waitlist.html")}this.currentUser={uid:e.uid,email:e.email,displayName:e.displayName,photoURL:e.photoURL,isGuest:!1},await G.loadFromFirebase(e.uid,{email:e.email,displayName:e.displayName,photoURL:e.photoURL}),console.log("User signed in:",e.displayName)}else this.currentUser=null,G.data=null,G.userId=null,console.log("User signed out");this.authStateListeners.forEach((e=>e(this.currentUser)))}))},async signInWithGoogle(){try{const e=await w(v,U);if(!window.location.pathname.includes("waitlist.html")){if(!(await F(e.user.uid,e.user.email)).approved)return window.location.href="waitlist.html",{success:!0,user:e.user,waitlist:!0}}return{success:!0,user:e.user}}catch(e){return console.error("Sign in error:",e),{success:!1,error:e.message}}},async signOut(){try{return await p(v),this.currentUser=null,{success:!0}}catch(e){return console.error("Sign out error:",e),{success:!1,error:e.message}}},isSignedIn(){return null!==this.currentUser&&!this.currentUser.isGuest},getUser(){return this.currentUser},onAuthStateChange(e){this.authStateListeners.push(e),void 0!==this.currentUser&&e(this.currentUser)},setGuestMode(){this.currentUser={uid:"guest_"+Date.now(),displayName:"Guest",isGuest:!0},this.authStateListeners.forEach((e=>e(this.currentUser)))}};window.Auth=z;const G={data:null,userId:null,getDefault:(e={})=>({email:e.email||null,displayName:e.displayName||null,photoURL:e.photoURL||null,balance:500,keys:40,positions:[],watchlist:[],transactions:[],cashOuts:[],createdAt:(new Date).toISOString(),lastLoginAt:(new Date).toISOString()}),async loadFromFirebase(e,t={}){this.userId=e;try{const o=await s(a(_,e));o.exists()?(this.data=o.data(),this.data.email=t.email||this.data.email,this.data.displayName=t.displayName||this.data.displayName,this.data.photoURL=t.photoURL||this.data.photoURL,this.data.lastLoginAt=(new Date).toISOString(),void 0===this.data.keys&&(this.data.keys=40),await this.save()):(this.data=this.getDefault(t),await r(a(_,e),this.data),console.log("Created new user document for:",e))}catch(e){console.error("Error loading user data:",e),this.data=this.getDefault(t)}return this.data},async save(){if(this.userId&&this.data)try{await r(a(_,this.userId),this.data)}catch(e){console.error("Error saving user data:",e)}},get(){return this.data||this.getDefault()},getBalance(){return this.get().balance},getKeys(){return this.get().keys||0},async updateKeys(e){return this.data?(this.data.keys=Math.max(0,(this.data.keys||0)+e),await this.save(),this.data.keys):0},STREAK_MULTIPLIERS:[1,1.2,1.4,1.7,2,2.4,2.8,3.2,3.6,4],BASE_KEY_REWARD:4,BASE_BALANCE_REWARD:150,getStreakMultiplier(e){const t=Math.min(e-1,this.STREAK_MULTIPLIERS.length-1);return t<0?this.STREAK_MULTIPLIERS[0]:this.STREAK_MULTIPLIERS[t]},getLastDailyKeyClaim(){return this.get().lastDailyKeyClaim||null},getDailyStreak(){return this.get().dailyStreak||0},canClaimDailyKey(){const e=this.getLastDailyKeyClaim();if(!e)return!0;const t=new Date(e).getTime();return(Date.now()-t)/36e5>=24},isStreakValid(){const e=this.getLastDailyKeyClaim();if(!e)return!1;const t=new Date(e).getTime();return(Date.now()-t)/36e5<48},getTimeUntilNextClaim(){const e=this.getLastDailyKeyClaim();if(!e)return 0;const t=new Date(e).getTime()+864e5,a=Date.now();return Math.max(0,t-a)},getStreakRewardInfo(){let e=this.getDailyStreak();!this.isStreakValid()&&e>0&&(e=0);const t=e+1,a=this.getStreakMultiplier(t);return{currentStreak:e,nextStreak:t,multiplier:a,keysReward:Math.floor(this.BASE_KEY_REWARD*a),balanceReward:Math.floor(this.BASE_BALANCE_REWARD*a)}},async claimDailyKey(){if(!this.data)return{success:!1,error:"Not signed in"};if(!this.canClaimDailyKey())return{success:!1,error:"Already claimed today"};try{let e=1;this.isStreakValid()&&(e=(this.data.dailyStreak||0)+1);const t=this.getStreakMultiplier(e),a=Math.floor(this.BASE_KEY_REWARD*t),r=Math.floor(this.BASE_BALANCE_REWARD*t);return this.data.keys=(this.data.keys||0)+a,this.data.balance=Math.round(100*((this.data.balance||0)+r))/100,this.data.dailyStreak=e,this.data.lastDailyKeyClaim=(new Date).toISOString(),await this.save(),{success:!0,keys:this.data.keys,balance:this.data.balance,keysReward:a,balanceReward:r,streak:e,multiplier:t}}catch(e){return console.error("Error claiming daily reward:",e),{success:!1,error:e.message}}},async updateProfile(e,t){if(!this.data)return{success:!1,error:"Not signed in"};try{return void 0!==e&&""!==e.trim()&&(this.data.displayName=e.trim(),this.data.customUserName=e.trim()),void 0!==t&&(this.data.avatarStyle=t),await this.save(),{success:!0}}catch(e){return console.error("Error updating profile:",e),{success:!1,error:e.message}}},getAvatarStyle(){return this.get().avatarStyle||"default"},getDisplayName(){return this.get().displayName||"Anonymous"},async updateBalance(e){return this.data?(this.data.balance=Math.round(100*(this.data.balance+e))/100,await this.save(),this.data.balance):0},async addPosition(e,t,s,o,i,n){if(!this.data)return[];const c="trade_"+Date.now()+"_"+Math.random().toString(36).substr(2,9),d=(new Date).toISOString(),l=this.data.positions.findIndex((t=>t.marketId===e&&t.choice===s));if(-1!==l){const e=this.data.positions[l];e.shares+=o,e.costBasis+=i,e.avgPrice=Math.round(e.costBasis/e.shares*100)/100,e.tradeIds=e.tradeIds||[],e.tradeIds.push(c)}else this.data.positions.push({marketId:e,marketTitle:t,choice:s,shares:o,costBasis:i,avgPrice:n,purchaseDate:d,tradeIds:[c]});this.data.transactions=this.data.transactions||[],this.data.transactions.unshift({type:"buy",marketId:e,choice:s,shares:o,price:n,cost:i,tradeId:c,timestamp:d}),await this.save();try{await r(a(D,c),{tradeId:c,userId:this.userId,marketId:e,marketTitle:t,choice:s,shares:o,costBasis:i,price:n,timestamp:d,status:"active"})}catch(e){console.warn("Could not save to central positions collection:",e)}return this.data.positions},getPositions(){return this.get().positions||[]},async sellPosition(e,t,a,r){if(!this.data)return null;const s=this.data.positions.findIndex((a=>a.marketId===e&&a.choice===t));if(-1===s)return null;const o=this.data.positions[s],i=o.costBasis/o.shares*a;return a>=o.shares?this.data.positions.splice(s,1):(o.shares-=a,o.costBasis-=i),this.data.transactions=this.data.transactions||[],this.data.transactions.unshift({type:"sell",marketId:e,choice:t,shares:a,price:Math.round(r/a*100),proceeds:r,profit:r-i,timestamp:(new Date).toISOString()}),await this.save(),{soldCostBasis:i,profit:r-i}},getPosition(e){return this.getPositions().find((t=>t.marketId===e))||null},getWatchlist(){return this.get().watchlist||[]},getCashOuts(){return this.get().cashOuts||[]},getSeenCashoutIds(){return this.get().seenCashoutIds||[]},getUnseenWins(){const e=this.getCashOuts(),t=this.getSeenCashoutIds();return e.filter((e=>e.won&&!t.includes(e.marketId+"_"+e.timestamp)))},async markCashoutsAsSeen(e){this.data&&(this.data.seenCashoutIds||(this.data.seenCashoutIds=[]),this.data.seenCashoutIds=[...new Set([...this.data.seenCashoutIds,...e])],await this.save())},async addToWatchlist(e){return this.data?(this.data.watchlist.includes(e)||(this.data.watchlist.push(e),await this.save()),this.data.watchlist):[]},async removeFromWatchlist(e){return this.data?(this.data.watchlist=this.data.watchlist.filter((t=>t!==e)),await this.save(),this.data.watchlist):[]},isWatchlisted(e){return(this.get().watchlist||[]).includes(e)},async reset(){this.data=this.getDefault(),await this.save()}};window.UserData=G;const q={STORAGE_KEY:"mulon_onboarding",hasCompletedOnboarding(){return"completed"===localStorage.getItem(this.STORAGE_KEY)},setCompleted(){localStorage.setItem(this.STORAGE_KEY,"completed")},reset(){localStorage.removeItem(this.STORAGE_KEY)}};window.OnboardingState=q;const V={books:{},async initBook(e){if(!this.books[e])try{const t=await s(a(I,"mulon_orderbooks",e));t.exists()?this.books[e]=t.data():(this.books[e]=this.createEmptyBook(),await this.saveOrderBook(e))}catch(t){console.warn("Could not load order book from Firebase:",t),this.books[e]=this.createEmptyBook()}return this.books[e]},createEmptyBook:()=>({yes:{bids:[],asks:[]},no:{bids:[],asks:[]},lastUpdated:(new Date).toISOString(),totalOrders:0,matchedOrders:0}),async saveOrderBook(e){try{const t=this.books[e];t&&(t.lastUpdated=(new Date).toISOString(),await r(a(I,"mulon_orderbooks",e),t))}catch(e){console.warn("Could not save order book to Firebase:",e)}},async addLimitOrder(e,t,a,r,s,o="anonymous"){const i=await this.initBook(e),n={orderId:"order_"+Date.now()+"_"+Math.random().toString(36).substr(2,9),price:Math.round(r),quantity:Math.round(100*s)/100,side:t,choice:a,userId:o,timestamp:(new Date).toISOString(),status:"open",filled:0},c=i[a];return"buy"===t?(c.bids.push(n),c.bids.sort(((e,t)=>t.price-e.price))):(c.asks.push(n),c.asks.sort(((e,t)=>e.price-t.price))),i.totalOrders++,await this.saveOrder(n),await this.saveOrderBook(e),await this.matchOrders(e,a),n},async saveOrder(e){try{await r(a(A,e.orderId),e)}catch(e){console.warn("Could not save order to Firebase:",e)}},async updateOrderStatus(e,t){try{await c(a(A,e),t)}catch(e){console.warn("Could not update order:",e)}},async matchOrders(e,t){const a=await this.initBook(e),r=a[t];for(;r.bids.length>0&&r.asks.length>0;){const s=r.bids[0],o=r.asks[0];if(!(s.price>=o.price))break;{const i=Math.round((s.price+o.price)/2),n=Math.min(s.quantity-s.filled,o.quantity-o.filled),c={id:"trade_"+Date.now(),marketId:e,choice:t,buyOrderId:s.orderId,sellOrderId:o.orderId,price:i,quantity:n,timestamp:(new Date).toISOString()};await this.saveTrade(c),s.filled+=n,o.filled+=n,s.filled>=s.quantity&&(s.status="filled",r.bids.shift(),await this.updateOrderStatus(s.orderId,{status:"filled",filled:s.filled})),o.filled>=o.quantity&&(o.status="filled",r.asks.shift(),await this.updateOrderStatus(o.orderId,{status:"filled",filled:o.filled})),a.matchedOrders++,await this.updateMarketPrice(e,t,i)}}await this.saveOrderBook(e)},async updateMarketPrice(e,t,a){if(!Y.getMarket(e))return;let r;r="yes"===t?{yesPrice:a,noPrice:100-a}:{noPrice:a,yesPrice:100-a},await Y.updateMarket(e,r)},async executeMarketOrder(e,t,a,r,s="anonymous"){await this.initBook(e);const o=Y.getMarket(e);if(!o)return{filled:!1,error:"Market not found"};const i="yes"===a?o.yesPrice:o.noPrice,n=r/(i/100),c=o.volume||1e3,d=Math.min(r/c,.15);let l,u;"buy"===t?"yes"===a?(l=Math.min(99,Math.round(o.yesPrice+100*d)),u=100-l):(u=Math.min(99,Math.round(o.noPrice+100*d)),l=100-u):"yes"===a?(l=Math.max(1,Math.round(o.yesPrice-100*d)),u=100-l):(u=Math.max(1,Math.round(o.noPrice-100*d)),l=100-u);const h={yesPrice:l,noPrice:u,volume:(o.volume||0)+Math.round(r)};await Y.updateMarket(e,h);const g={id:"trade_"+Date.now(),marketId:e,side:t,choice:a,shares:Math.round(100*n)/100,price:i,cost:r,priceAfter:"yes"===a?l:u,userId:s,orderType:"market",timestamp:(new Date).toISOString()};return await this.saveTrade(g),await this.updateOrderBookFromTrade(e,g),{filled:!0,shares:g.shares,avgPrice:i,cost:r,newPrice:"yes"===a?l:u,priceChange:("yes"===a?l:u)-i}},async updateOrderBookFromTrade(e,t){const a=await this.initBook(e);a.recentTrades||(a.recentTrades=[]),a.recentTrades.unshift({price:t.price,shares:t.shares,side:t.side,timestamp:t.timestamp}),a.recentTrades.length>50&&(a.recentTrades=a.recentTrades.slice(0,50)),await this.saveOrderBook(e)},async saveTrade(e){try{await r(a(C,e.id),e)}catch(e){console.warn("Could not save trade to Firebase:",e)}},async getRecentTrades(e,t=20){try{const a=await o(C),r=[];return a.forEach((t=>{const a=t.data();a.marketId===e&&r.push(a)})),r.sort(((e,t)=>new Date(t.timestamp)-new Date(e.timestamp))),0===t?r:r.slice(0,t)}catch(e){return console.warn("Could not fetch trades:",e),[]}},async getOrderBook(e){return await this.initBook(e)},async getOpenOrders(e){const t=await this.initBook(e);return{yes:{bids:t.yes.bids.filter((e=>"open"===e.status)),asks:t.yes.asks.filter((e=>"open"===e.status))},no:{bids:t.no.bids.filter((e=>"open"===e.status)),asks:t.no.asks.filter((e=>"open"===e.status))}}},async cancelOrder(e,t){const a=await this.initBook(e);for(const r of["yes","no"])for(const s of["bids","asks"]){const o=a[r][s].findIndex((e=>e.orderId===t));if(-1!==o)return a[r][s][o].status="cancelled",a[r][s].splice(o,1),await this.updateOrderStatus(t,{status:"cancelled"}),await this.saveOrderBook(e),!0}return!1},getProbability:e=>e,async getSpread(e,t){const a=await this.initBook(e),r=Y.getMarket(e);if(!r)return null;const s=a[t],o=s.bids[0],i=s.asks[0],n="yes"===t?r.yesPrice:r.noPrice;return{bid:o?o.price:Math.max(1,n-1),ask:i?i.price:Math.min(99,n+1),mid:n,bidQuantity:o?o.quantity-o.filled:0,askQuantity:i?i.quantity-i.filled:0}},async getDepth(e,t,a=5){const r=(await this.initBook(e))[t],s=e=>{const t={};return e.forEach((e=>{t[e.price]||(t[e.price]=0),t[e.price]+=e.quantity-e.filled})),Object.entries(t).map((([e,t])=>({price:parseInt(e),quantity:t})))};return{bids:s(r.bids).slice(0,a),asks:s(r.asks).slice(0,a)}}};window.OrderBook=V;const Y={STORAGE_KEY:"mulon_markets",isInitialized:!1,cachedMarkets:[],defaultMarkets:[{id:"market_1",title:"When will Torre grade the next exam?",subtitle:"Will Mr. Torre post grades before February 1st?",category:"grading",categoryIcon:"ðŸ“",categoryLabel:"Grading",yesPrice:69,noPrice:31,volume:2400,startDate:"2026-01-15",endDate:"2026-02-01",status:"active",featured:!0,createdAt:"2026-01-15T10:00:00Z",totalShares:{yes:2400,no:1100},orderBookId:"market_1"},{id:"market_2",title:"Will the basketball team win Friday's game?",subtitle:"Tech High vs Central High",category:"sports",categoryIcon:"âš½",categoryLabel:"Sports",yesPrice:45,noPrice:55,volume:1200,startDate:"2026-01-20",endDate:"2026-01-24",status:"active",featured:!1,createdAt:"2026-01-20T09:00:00Z",totalShares:{yes:540,no:660},orderBookId:"market_2"},{id:"market_3",title:"Will the cafeteria serve pizza on Monday?",subtitle:"Weekly menu prediction",category:"school",categoryIcon:"ðŸŽ“",categoryLabel:"Tech High",yesPrice:82,noPrice:18,volume:850,startDate:"2026-01-21",endDate:"2026-01-27",status:"active",featured:!1,createdAt:"2026-01-21T08:00:00Z",totalShares:{yes:697,no:153},orderBookId:"market_3"},{id:"market_4",title:"Will student council approve the new club?",subtitle:"Gaming Club proposal vote",category:"politics",categoryIcon:"ðŸ›ï¸",categoryLabel:"Politics",yesPrice:58,noPrice:42,volume:640,startDate:"2026-01-18",endDate:"2026-02-01",status:"active",featured:!1,createdAt:"2026-01-18T14:00:00Z",totalShares:{yes:371,no:269},orderBookId:"market_4"},{id:"market_5",title:"Will class average exceed 85% on final?",subtitle:"AP Chemistry final exam",category:"grading",categoryIcon:"ðŸ“",categoryLabel:"Grading",yesPrice:34,noPrice:66,volume:920,startDate:"2026-01-10",endDate:"2026-02-15",status:"active",featured:!1,createdAt:"2026-01-10T11:00:00Z",totalShares:{yes:313,no:607},orderBookId:"market_5"}],categories:{},defaultCategories:{school:{icon:"ðŸŽ“",label:"Tech High",color:"school"},sports:{icon:"âš½",label:"Sports",color:"sports"},politics:{icon:"ðŸ›ï¸",label:"Politics",color:"politics"},grading:{icon:"ðŸ“",label:"Grading",color:"grading"}},async fetchCategories(){try{const e=await o(O),t={};return e.forEach((e=>{t[e.id]=e.data()})),0===Object.keys(t).length?(console.log("No categories in Firebase, initializing with defaults..."),await this.initializeCategoriesWithDefaults(),this.categories={...this.defaultCategories}):this.categories=t,this.categories}catch(e){return console.error("Error fetching categories:",e),this.categories={...this.defaultCategories},this.categories}},async initializeCategoriesWithDefaults(){try{for(const[e,t]of Object.entries(this.defaultCategories))await r(a(O,e),t);console.log("Categories initialized in Firebase")}catch(e){console.error("Error initializing categories:",e)}},async addCategory(e,t,s,o){M();try{const i={icon:t,label:s,color:o||e};return await r(a(O,e),i),this.categories[e]=i,console.log("Category added:",e),{success:!0,category:i}}catch(e){return console.error("Error adding category:",e),{success:!1,error:e.message}}},async updateCategory(e,t){M();try{return await c(a(O,e),t),this.categories[e]={...this.categories[e],...t},console.log("Category updated:",e),{success:!0}}catch(e){return console.error("Error updating category:",e),{success:!1,error:e.message}}},async deleteCategory(e){M();try{return await i(a(O,e)),delete this.categories[e],console.log("Category deleted:",e),{success:!0}}catch(e){return console.error("Error deleting category:",e),{success:!1,error:e.message}}},getCategories(){return this.categories},getCategory(e){return this.categories[e]||{icon:"ðŸ“Š",label:"Other",color:"other"}},async submitSuggestion(e,t,o,i,n,c){try{const d=v.currentUser;if(d){if(d.email){const e=d.email.toLowerCase().replace(/[.#$[\]]/g,"_");if((await s(a(P,e))).exists())return console.log("Banned user attempted to submit suggestion"),{success:!1,error:"You are banned from submitting suggestions."}}const e=await s(a(_,d.uid));if(e.exists()&&!0===e.data().banned)return console.log("Banned user attempted to submit suggestion"),{success:!1,error:"You are banned from submitting suggestions."}}const l="sug_"+Date.now(),u={id:l,title:e,category:t||null,reason:o||"",userId:i||null,userEmail:n||"Anonymous",userName:c||"Anonymous",status:"pending",createdAt:(new Date).toISOString()};return await r(a(N,l),u),console.log("Suggestion submitted:",l),{success:!0,id:l}}catch(e){return console.error("Error submitting suggestion:",e),{success:!1,error:e.message}}},async getSuggestions(){try{const e=await o(N),t=[];return e.forEach((e=>{t.push({id:e.id,...e.data()})})),t.sort(((e,t)=>new Date(t.createdAt)-new Date(e.createdAt))),t}catch(e){return console.error("Error fetching suggestions:",e),[]}},async updateSuggestionStatus(e,t){M();try{return await c(a(N,e),{status:t}),{success:!0}}catch(e){return console.error("Error updating suggestion:",e),{success:!1,error:e.message}}},async deleteSuggestion(e){M();try{return await i(a(N,e)),{success:!0}}catch(e){return console.error("Error deleting suggestion:",e),{success:!1,error:e.message}}},async init(){if(this.isInitialized)return this.cachedMarkets;try{await this.fetchCategories();const e=await this.fetchMarketsFromFirebase();return 0===e.length?(console.log("No markets in Firebase, initializing with defaults..."),await this.initializeFirebaseWithDefaults(),this.cachedMarkets=this.defaultMarkets):this.cachedMarkets=e,this.isInitialized=!0,this.cachedMarkets}catch(e){return console.error("Error initializing MulonData:",e),this.cachedMarkets=this.defaultMarkets,this.cachedMarkets}},async fetchMarketsFromFirebase(){try{const e=await o(E),t=[];return e.forEach((e=>{t.push({id:e.id,...e.data()})})),t}catch(e){return console.error("Error fetching markets from Firebase:",e),[]}},async initializeFirebaseWithDefaults(){try{for(const e of this.defaultMarkets)await r(a(E,e.id),e);console.log("Firebase initialized with default markets")}catch(e){console.error("Error initializing Firebase with defaults:",e)}},async transferFromLocalStorage(){const e=localStorage.getItem(this.STORAGE_KEY);if(!e)return console.log("No localStorage data to transfer"),!1;try{const t=JSON.parse(e);console.log(`Transferring ${t.length} markets to Firebase...`);for(const e of t)await r(a(E,e.id),e),console.log(`Transferred: ${e.title}`);return console.log("Transfer complete!"),!0}catch(e){return console.error("Error transferring to Firebase:",e),!1}},async getMarkets(){return this.isInitialized||await this.init(),this.cachedMarkets},getMarketsSync(){return this.cachedMarkets},async refreshMarkets(){return this.cachedMarkets=await this.fetchMarketsFromFirebase(),this.cachedMarkets},async addMarket(e){M();const t={id:"market_"+Date.now(),...e,createdAt:(new Date).toISOString(),status:"active",totalShares:{yes:0,no:0},orderBookId:"market_"+Date.now()};try{return await r(a(E,t.id),t),await V.initBook(t.id),this.cachedMarkets.push(t),console.log("Market added:",t.title),t}catch(e){return console.error("Error adding market:",e),null}},async updateMarket(e,t){M();try{const r=a(E,e);await c(r,t);const s=this.cachedMarkets.findIndex((t=>t.id===e));return-1!==s&&(this.cachedMarkets[s]={...this.cachedMarkets[s],...t}),console.log("Market updated:",e),this.cachedMarkets[s]}catch(e){return console.error("Error updating market:",e),null}},async resolveMarket(e,t){M();try{const r=this.getMarket(e);if(!r)return{success:!1,error:"Market not found"};if(r.resolved)return{success:!1,error:"Market already resolved"};const s=await o(_);let i=0;const n=[];for(const o of s.docs){const s=o.data(),d=s.positions||[],l=d.filter((t=>t.marketId===e));if(l.length>0){let u=0;const h=d.filter((t=>t.marketId!==e)),g=[];for(const a of l){const s=a.choice===t,o=s?a.shares:0;g.push({marketId:e,marketTitle:r.title,position:a.choice,shares:a.shares,avgPrice:a.avgPrice||Math.round(a.costBasis/a.shares*100)/100,cost:a.costBasis,outcome:t,won:s,payout:o,timestamp:(new Date).toISOString()}),s&&(u+=o,i++)}const m=s.cashOuts||[],y=(s.balance||0)+u,w=g.some((e=>e.won)),p=s.keys||0,f={positions:h,balance:Math.round(100*y)/100,cashOuts:[...m,...g]};w&&(f.keys=p+10),await c(a(_,o.id),f),n.push(...g)}}return await this.updateMarket(e,{resolved:!0,resolvedOutcome:t,resolvedAt:(new Date).toISOString()}),console.log(`Market ${e} resolved as ${t}. ${i} winning positions paid out.`),{success:!0,payoutCount:i,cashOuts:n}}catch(e){return console.error("Error resolving market:",e),{success:!1,error:e.message}}},async deleteMarket(e){M();try{return await i(a(E,e)),this.cachedMarkets=this.cachedMarkets.filter((t=>t.id!==e)),console.log("Market deleted:",e),this.cachedMarkets}catch(e){return console.error("Error deleting market:",e),this.cachedMarkets}},getMarket(e){return this.cachedMarkets.find((t=>t.id===e))},async getMarketFromFirebase(e){try{const t=await s(a(E,e));return t.exists()?{id:t.id,...t.data()}:null}catch(e){return console.error("Error fetching market:",e),null}},getMarketsByCategory(e){return"all"===e?this.cachedMarkets:this.cachedMarkets.filter((t=>t.category===e))},getFeaturedMarkets(){return this.cachedMarkets.filter((e=>e.featured))},getActiveMarkets(){return this.cachedMarkets.filter((e=>"active"===e.status))},formatVolume:e=>e>=1e3?"$"+(e/1e3).toFixed(1)+"k Vol.":"$"+e+" Vol.",formatDate:e=>new Date(e).toLocaleDateString("en-US",{month:"short",day:"numeric"}),getDaysUntil(e){const t=new Date(e),a=new Date,r=Math.ceil((t-a)/864e5);return r<=0?"Ended":1===r?"Ends tomorrow":`Ends in ${r} days`},async resetToDefaults(){M();try{const e=await o(E),t=[];return e.forEach((e=>{t.push(i(a(E,e.id)))})),await Promise.all(t),await this.initializeFirebaseWithDefaults(),this.cachedMarkets=[...this.defaultMarkets],console.log("Reset to defaults complete"),this.cachedMarkets}catch(e){return console.error("Error resetting to defaults:",e),this.cachedMarkets}},async getMarketTradesWithUsers(e){try{const t=await o(C),r=[],i=new Set;t.forEach((t=>{const a=t.data();a.marketId===e&&(r.push(a),a.userId&&i.add(a.userId))})),r.sort(((e,t)=>new Date(t.timestamp)-new Date(e.timestamp)));const n={};for(const e of i)try{const t=await s(a(_,e));if(t.exists()){const a=t.data();n[e]={displayName:a.displayName||"Anonymous",email:a.email||"Unknown",photoURL:a.photoURL||null}}else n[e]={displayName:"Unknown User",email:"N/A",photoURL:null}}catch(t){n[e]={displayName:"Unknown User",email:"N/A",photoURL:null}}return r.map((e=>({...e,user:n[e.userId]||{displayName:"Guest",email:"N/A",photoURL:null}})))}catch(e){return console.error("Error fetching market trades with users:",e),[]}},async getMarketPositions(e){try{const t=await o(_),a=[];for(const r of t.docs){const t=r.data(),s=(t.positions||[]).find((t=>t.marketId===e));s&&a.push({userId:r.id,displayName:t.displayName||"Anonymous",email:t.email||"Unknown",photoURL:t.photoURL||null,...s})}return a.sort(((e,t)=>t.shares-e.shares)),a}catch(e){return console.error("Error fetching market positions:",e),[]}},async getAllUsers(){try{const e=await o(_),t=[];for(const a of e.docs){const e=a.data();t.push({id:a.id,displayName:e.displayName||"Anonymous",email:e.email||"Unknown",photoURL:e.photoURL||null,keys:e.keys||0,balance:e.balance||0,positions:e.positions||[],ownedCards:e.ownedCards||[],createdAt:e.createdAt||null,lastLoginAt:e.lastLoginAt||null,banned:e.banned||!1,bannedAt:e.bannedAt||null,bannedReason:e.bannedReason||null})}return t.sort(((e,t)=>t.balance-e.balance)),t}catch(e){return console.error("Error fetching all users:",e),[]}},async updateUserBalance(e,t){M();try{const r=await s(a(_,e)),o=r.exists()&&r.data().balance||0,i=r.exists()?r.data():{},n=Math.round(100*t)/100;return await c(a(_,e),{balance:n}),await W("balance_update",{targetUserId:e,targetUserEmail:i.email||null,targetUserName:i.displayName||null,beforeValue:o,afterValue:n}),{success:!0}}catch(e){return console.error("Error updating user balance:",e),{success:!1,error:e.message}}},async updateUserKeys(e,t){M();try{const r=await s(a(_,e)),o=r.exists()&&r.data().keys||0,i=r.exists()?r.data():{},n=Math.max(0,Math.round(t));return await c(a(_,e),{keys:n}),await W("keys_update",{targetUserId:e,targetUserEmail:i.email||null,targetUserName:i.displayName||null,beforeValue:o,afterValue:n}),{success:!0}}catch(e){return console.error("Error updating user keys:",e),{success:!1,error:e.message}}},async bulkUpdateKeys(e,t="add"){M();try{const r=await o(_);let s=0;for(const o of r.docs){const r=o.data().keys||0;let i;"set"===t?i=e:"add"===t?i=r+e:"subtract"===t?i=Math.max(0,r-e):"multiply"===t&&(i=r*e),i=Math.max(0,Math.round(i)),await c(a(_,o.id),{keys:i}),s++}return await W("bulk_keys_update",{operation:t,amount:e,usersAffected:s}),{success:!0,updatedCount:s}}catch(e){return console.error("Error bulk updating keys:",e),{success:!1,error:e.message}}},async adjustUserBalance(e,t){M();try{const r=await s(a(_,e));if(!r.exists())return{success:!1,error:"User not found"};const o=r.data().balance||0,i=Math.round(100*(o+t))/100;return await c(a(_,e),{balance:i}),{success:!0,newBalance:i}}catch(e){return console.error("Error adjusting user balance:",e),{success:!1,error:e.message}}},async bulkUpdateBalances(e,t="add"){M();try{const r=await o(_);let s=0;for(const o of r.docs){const r=o.data().balance||0;let i;"set"===t?i=e:"add"===t?i=r+e:"subtract"===t?i=Math.max(0,r-e):"multiply"===t&&(i=r*e),i=Math.round(100*i)/100,await c(a(_,o.id),{balance:i}),s++}return await W("bulk_balance_update",{operation:t,amount:e,usersAffected:s}),{success:!0,updatedCount:s}}catch(e){return console.error("Error bulk updating balances:",e),{success:!1,error:e.message}}},async resetUserPositions(e){M();try{const t=await s(a(_,e));if(!t.exists())return{success:!1,error:"User not found"};const r=t.data(),o=r.positions||[],n=o.length;for(const e of o){const t=Math.round(e.costBasis||0);if(t>0){const a=this.getMarket(e.marketId);if(a){const r=Math.max(0,(a.volume||0)-t);await this.updateMarket(e.marketId,{volume:r})}}if(e.tradeIds)for(const t of e.tradeIds)try{await i(a(D,t)),await i(a(C,t))}catch(e){console.warn("Could not delete position/trade:",t)}}return await c(a(_,e),{positions:[]}),await W("user_positions_reset",{targetUserId:e,targetUserEmail:r.email||null,targetUserName:r.displayName||null,positionsDeleted:n}),{success:!0}}catch(e){return console.error("Error resetting user positions:",e),{success:!1,error:e.message}}},async resetAllUsersPositions(){M();try{const e=await o(_);let t=0;const r={};for(const s of e.docs){const e=s.data().positions||[];for(const t of e){const e=Math.round(t.costBasis||0);if(e>0&&(r[t.marketId]=(r[t.marketId]||0)+e),t.tradeIds)for(const e of t.tradeIds)try{await i(a(D,e)),await i(a(C,e))}catch(t){console.warn("Could not delete position/trade:",e)}}await c(a(_,s.id),{positions:[]}),t++}for(const[e,t]of Object.entries(r)){const a=this.getMarket(e);if(a){const r=Math.max(0,(a.volume||0)-t);await this.updateMarket(e,{volume:r})}}return{success:!0,resetCount:t}}catch(e){return console.error("Error resetting all positions:",e),{success:!1,error:e.message}}},async resetUser(e,t=500){M();try{return await c(a(_,e),{balance:t,positions:[]}),{success:!0}}catch(e){return console.error("Error resetting user:",e),{success:!1,error:e.message}}},async resetAllUsers(e=500){M();try{const t=await o(_);let r=0;for(const s of t.docs)await c(a(_,s.id),{balance:e,positions:[]}),r++;return{success:!0,resetCount:r}}catch(e){return console.error("Error resetting all users:",e),{success:!1,error:e.message}}},async updateUserCards(e,t){M();try{const r=await s(a(_,e)),o=r.exists()&&r.data().ownedCards||[],i=r.exists()?r.data():{};return await c(a(_,e),{ownedCards:t}),await W("cards_update",{targetUserId:e,targetUserEmail:i.email||null,targetUserName:i.displayName||null,beforeCount:o.length,afterCount:t.length}),{success:!0}}catch(e){return console.error("Error updating user cards:",e),{success:!1,error:e.message}}},async addCardToUser(e,t){M();try{const r=await s(a(_,e));if(!r.exists())return{success:!1,error:"User not found"};const o=r.data(),i=(o.ownedCards,{...t,addedAt:(new Date).toISOString(),addedBy:"admin"});return await c(a(_,e),{ownedCards:h(i)}),await W("card_added",{targetUserId:e,targetUserEmail:o.email||null,targetUserName:o.displayName||null,cardNumber:t.cardNumber}),{success:!0}}catch(e){return console.error("Error adding card to user:",e),{success:!1,error:e.message}}},async removeCardFromUser(e,t){M();try{const r=await s(a(_,e));if(!r.exists())return{success:!1,error:"User not found"};const o=r.data(),i=o.ownedCards||[],n=i.findIndex((e=>e.cardNumber===t));if(-1===n)return{success:!1,error:"Card not found"};const d=[...i];return d.splice(n,1),await c(a(_,e),{ownedCards:d}),await W("card_removed",{targetUserId:e,targetUserEmail:o.email||null,targetUserName:o.displayName||null,cardNumber:t}),{success:!0}}catch(e){return console.error("Error removing card from user:",e),{success:!1,error:e.message}}},async resetUserCards(e){M();try{const t=await s(a(_,e));if(!t.exists())return{success:!1,error:"User not found"};const r=t.data(),o=(r.ownedCards||[]).length;return await c(a(_,e),{ownedCards:[]}),await W("user_cards_reset",{targetUserId:e,targetUserEmail:r.email||null,targetUserName:r.displayName||null,cardsDeleted:o}),{success:!0}}catch(e){return console.error("Error resetting user cards:",e),{success:!1,error:e.message}}},async resetAllUsersCards(){M();try{const e=await o(_);let t=0,r=0;for(const s of e.docs){const e=s.data();r+=(e.ownedCards||[]).length,await c(a(_,s.id),{ownedCards:[]}),t++}return await W("all_cards_reset",{usersAffected:t,totalCardsDeleted:r}),{success:!0,resetCount:t,totalCardsDeleted:r}}catch(e){return console.error("Error resetting all user cards:",e),{success:!1,error:e.message}}},async bulkAddCardToAllUsers(e){M();try{const t=await o(_);let r=0;for(const s of t.docs){const t={...e,addedAt:(new Date).toISOString(),addedBy:"admin_bulk"};await c(a(_,s.id),{ownedCards:h(t)}),r++}return await W("bulk_card_add",{cardNumber:e.cardNumber,usersAffected:r}),{success:!0,updatedCount:r}}catch(e){return console.error("Error bulk adding card:",e),{success:!1,error:e.message}}},async bulkRemoveCardFromAllUsers(e){M();try{const t=await o(_);let r=0,s=0;for(const o of t.docs){const t=o.data().ownedCards||[],i=t.filter((t=>t.cardNumber!==e)),n=t.length-i.length;n>0&&(await c(a(_,o.id),{ownedCards:i}),r++,s+=n)}return await W("bulk_card_remove",{cardNumber:e,usersAffected:r,cardsRemoved:s}),{success:!0,updatedCount:r,cardsRemoved:s}}catch(e){return console.error("Error bulk removing card:",e),{success:!1,error:e.message}}},async updateUserPosition(e,t,r){M();try{const o=await s(a(_,e));if(!o.exists())return{success:!1,error:"User not found"};const i=o.data().positions||[],n=i.findIndex((e=>e.marketId===t));return-1===n?{success:!1,error:"Position not found"}:(i[n]={...i[n],...r},await c(a(_,e),{positions:i}),{success:!0})}catch(e){return console.error("Error updating user position:",e),{success:!1,error:e.message}}},async deleteUserPosition(e,t){M();try{const r=await s(a(_,e));if(!r.exists())return{success:!1,error:"User not found"};const n=r.data().positions||[],d=n.find((e=>e.marketId===t));if(!d)return{success:!1,error:"Position not found"};const l=Math.round(d.costBasis||0),u=n.filter((e=>e.marketId!==t));if(await c(a(_,e),{positions:u}),l>0){const e=this.getMarket(t);if(e){const a=Math.max(0,(e.volume||0)-l);await this.updateMarket(t,{volume:a})}}if(d.tradeIds&&d.tradeIds.length>0)for(const e of d.tradeIds)try{await i(a(D,e)),await i(a(C,e))}catch(t){console.warn("Could not delete position/trade:",e,t)}try{const r=await o(C);for(const s of r.docs){const r=s.data();r.userId===e&&r.marketId===t&&await i(a(C,s.id))}}catch(e){console.warn("Could not clean up related trades:",e)}return{success:!0,volumeRemoved:l}}catch(e){return console.error("Error deleting user position:",e),{success:!1,error:e.message}}},async getUserById(e){try{const t=await s(a(_,e));if(!t.exists())return null;const r=t.data();return{id:t.id,displayName:r.displayName||"Anonymous",email:r.email||"Unknown",photoURL:r.photoURL||null,balance:r.balance||0,keys:r.keys||0,positions:r.positions||[],createdAt:r.createdAt||null,lastLoginAt:r.lastLoginAt||null,banned:r.banned||!1,bannedAt:r.bannedAt||null,bannedReason:r.bannedReason||null,deviceFingerprints:r.deviceFingerprints||[]}}catch(e){return console.error("Error fetching user:",e),null}},async banUser(e,t="",o=!1){M();try{const o=await s(a(_,e));if(!o.exists())return{success:!1,error:"User not found"};const n=o.data(),d=n.positions||[];for(const e of d)if(e.tradeIds&&e.tradeIds.length>0)for(const t of e.tradeIds)try{await i(a(D,t)),await i(a(C,t))}catch(e){console.warn("Could not delete position/trade:",t)}if(await c(a(_,e),{banned:!0,bannedAt:(new Date).toISOString(),bannedReason:t||"No reason provided",balance:0,keys:0,positions:[],watchlist:[],cashOuts:[],transactions:[],dailyStreak:0,lastDailyKeyClaim:null}),n.deviceFingerprints&&n.deviceFingerprints.length>0)for(const s of n.deviceFingerprints)await r(a(L,s),{fingerprint:s,bannedAt:(new Date).toISOString(),userId:e,userEmail:n.email||null,reason:t||"No reason provided"});if(n.email){const s=n.email.toLowerCase().replace(/[.#$[\]]/g,"_");await r(a(P,s),{email:n.email.toLowerCase(),bannedAt:(new Date).toISOString(),userId:e,displayName:n.displayName||null,reason:t||"No reason provided",permanent:!0})}return await W("user_banned",{targetUserId:e,targetUserEmail:n.email||null,targetUserName:n.displayName||null,reason:t||"No reason provided",deviceBanned:!0,devicesAffected:n.deviceFingerprints?.length||0,positionsCleared:d.length,balanceCleared:n.balance||0,keysCleared:n.keys||0}),{success:!0}}catch(e){return console.error("Error banning user:",e),{success:!1,error:e.message}}},async unbanUser(e,t=!1){M();try{const r=await s(a(_,e));if(!r.exists())return{success:!1,error:"User not found"};const o=r.data();if(await c(a(_,e),{banned:!1,bannedAt:null,bannedReason:null}),t&&o.deviceFingerprints&&o.deviceFingerprints.length>0)for(const e of o.deviceFingerprints)try{await i(a(L,e))}catch(t){console.warn("Could not remove device ban:",e)}if(o.email){const e=o.email.toLowerCase().replace(/[.#$[\]]/g,"_");try{await i(a(P,e))}catch(e){console.warn("Could not remove email ban:",o.email)}}return await W("user_unbanned",{targetUserId:e,targetUserEmail:o.email||null,targetUserName:o.displayName||null,deviceBansRemoved:t}),{success:!0}}catch(e){return console.error("Error unbanning user:",e),{success:!1,error:e.message}}},async checkUserBanned(e){try{const t=await s(a(_,e));if(!t.exists())return{banned:!1};const r=t.data();return{banned:!0===r.banned,reason:r.bannedReason||null,bannedAt:r.bannedAt||null}}catch(e){return console.error("Error checking ban status:",e),{banned:!1}}},async checkDeviceBanned(e){try{const t=await s(a(L,e));return t.exists()?{banned:!0,reason:t.data().reason||null,bannedAt:t.data().bannedAt||null}:{banned:!1}}catch(e){return console.error("Error checking device ban:",e),{banned:!1}}},async storeDeviceFingerprint(e,t){try{return await c(a(_,e),{deviceFingerprints:h(t)}),{success:!0}}catch(e){return console.error("Error storing device fingerprint:",e),{success:!1}}},async getWaitlist(){M();try{const e=await o(x),t=[];for(const a of e.docs){const e=a.data();t.push({id:a.id,uid:e.uid,email:e.email||"Unknown",displayName:e.displayName||"Anonymous",photoURL:e.photoURL||null,status:e.status||"pending",joinedAt:e.joinedAt,approvedAt:e.approvedAt||null,rejectedAt:e.rejectedAt||null,deviceFingerprint:e.deviceFingerprint||null})}return t}catch(e){return console.error("Error fetching waitlist:",e),[]}},async updateWaitlistStatus(e,t){M();try{const r={status:t};"approved"===t?r.approvedAt=(new Date).toISOString():"rejected"===t&&(r.rejectedAt=(new Date).toISOString()),await c(a(x,e),r);const o=await s(a(x,e)),i=o.exists()?o.data():{};return await W("waitlist_"+t,{targetUserId:e,targetUserEmail:i.email||null,targetUserName:i.displayName||null}),{success:!0}}catch(e){return console.error("Error updating waitlist status:",e),{success:!1,error:e.message}}},async deleteWaitlistEntry(e){M();try{return await i(a(x,e)),{success:!0}}catch(e){return console.error("Error deleting waitlist entry:",e),{success:!1,error:e.message}}}};window.MulonData=Y;export{Y as MulonData,V as OrderBook,z as Auth,G as UserData,q as OnboardingState,j as OverUnderSync,I as db,v as auth,E as marketsRef,O as categoriesRef,N as suggestionsRef,D as positionsRef,C as tradesRef,x as waitlistRef};