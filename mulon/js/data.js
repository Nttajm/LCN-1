import{initializeApp}from"https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";import{getFirestore,doc,setDoc,getDoc,getDocs,deleteDoc,collection,updateDoc,query,where,orderBy,arrayUnion,increment,addDoc}from"https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";import{getAuth,signInWithPopup,signOut,GoogleAuthProvider,onAuthStateChanged}from"https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";const firebaseConfig={apiKey:"AIzaSyAGcg43F94bWqUuyLH-AjghrAfduEVQ8ZM",authDomain:"overunder-ths.firebaseapp.com",projectId:"overunder-ths",storageBucket:"overunder-ths.firebasestorage.app",messagingSenderId:"690530120785",appId:"1:690530120785:web:36dc297cb517ac76cb7470",measurementId:"G-Q30T39R8VY"},app=initializeApp(firebaseConfig),db=getFirestore(app),auth=getAuth(app),googleProvider=new GoogleAuthProvider,ADMIN_EMAILS=Object.freeze(["joelmulonde81@gmail.com","jordan.herrera@crpusd.org","kaidenchatigny@gmail.com","captrojolmao@gmail.com"]);function requireAdmin(){const e=auth.currentUser;if(!e)throw new Error("UNAUTHORIZED: No user signed in");if(!e.email||!ADMIN_EMAILS.includes(e.email.toLowerCase()))throw new Error("UNAUTHORIZED: Admin access required");return!0}const marketsRef=collection(db,"mulon"),ordersRef=collection(db,"mulon_orders"),tradesRef=collection(db,"mulon_trades"),positionsRef=collection(db,"mulon_positions"),usersRef=collection(db,"mulon_users"),categoriesRef=collection(db,"mulon_categories"),suggestionsRef=collection(db,"mulon_suggestions"),ouUsersRef=collection(db,"users"),adminEditsRef=collection(db,"admin_edits"),bannedDevicesRef=collection(db,"mulon_banned_devices"),bannedEmailsRef=collection(db,"mulon_banned_emails"),waitlistRef=collection(db,"mulon_waitlist"),WAITLIST_ENABLED=!0;async function checkWaitlistAccess(e,t){if(t&&ADMIN_EMAILS.includes(t.toLowerCase()))return{approved:!0,isAdmin:!0};try{if((await getDoc(doc(usersRef,e))).exists())return{approved:!0,isExistingUser:!0};const t=await getDoc(doc(waitlistRef,e));if(!t.exists())return{approved:!1,status:"not_on_list"};const r=t.data();return"approved"===r.status?{approved:!0}:"rejected"===r.status?{approved:!1,status:"rejected"}:{approved:!1,status:"pending"}}catch(e){return console.error("Waitlist check error:",e),{approved:!0,error:!0}}}async function logAdminAction(e,t={}){try{const r=auth.currentUser;if(!r)return;const s={adminEmail:r.email,adminUid:r.uid,actionType:e,timestamp:(new Date).toISOString(),...t};await addDoc(adminEditsRef,s),console.log("Admin action logged:",e)}catch(e){console.error("Error logging admin action:",e)}}function generateDeviceFingerprint(){let e=0;const t=[navigator.userAgent,navigator.language,screen.width+"x"+screen.height,screen.colorDepth,(new Date).getTimezoneOffset(),navigator.hardwareConcurrency||"unknown",navigator.platform].join("|");for(let r=0;r<t.length;r++){e=(e<<5)-e+t.charCodeAt(r),e&=e}let r=localStorage.getItem("mulon_device_id");return r||(r="dev_"+Date.now()+"_"+Math.random().toString(36).substring(2,15),localStorage.setItem("mulon_device_id",r)),r+"_"+Math.abs(e).toString(36)}async function checkBanStatus(){try{const e=auth.currentUser,t=generateDeviceFingerprint();if((await getDoc(doc(bannedDevicesRef,t))).exists())return console.log("Device is banned, redirecting..."),window.location.href="https://parismou.org/PMoU-Procedures/Library/banning",!0;if(e){if(e.email){const t=e.email.toLowerCase().replace(/[.#$[\]]/g,"_");if((await getDoc(doc(bannedEmailsRef,t))).exists())return console.log("Email is banned, redirecting..."),window.location.href="https://parismou.org/PMoU-Procedures/Library/banning",!0}const r=await getDoc(doc(usersRef,e.uid));if(r.exists()&&!0===r.data().banned)return console.log("User is banned, redirecting..."),window.location.href="https://parismou.org/PMoU-Procedures/Library/banning",!0;await updateDoc(doc(usersRef,e.uid),{deviceFingerprints:arrayUnion(t)}).catch((()=>{}))}return!1}catch(e){return console.error("Error checking ban status:",e),!1}}window.checkWaitlistAccess=checkWaitlistAccess,window.WAITLIST_ENABLED=true,window.checkBanStatus=checkBanStatus,window.generateDeviceFingerprint=generateDeviceFingerprint;const OverUnderSync={async checkForOverUnderAccount(e){if(!e)return null;try{const t=query(ouUsersRef,where("email","==",e)),r=await getDocs(t);if(!r.empty){const e=r.docs[0],t=e.data();return{found:!0,uid:e.id,username:t.username||null,name:t.name||null,email:t.email}}return{found:!1}}catch(e){return console.error("Error checking Over Under account:",e),{found:!1,error:e.message}}},async syncUsername(e,t){try{return await updateDoc(doc(usersRef,e),{displayName:t,overUnderSynced:!0}),{success:!0}}catch(e){return console.error("Error syncing username:",e),{success:!1,error:e.message}}}};window.OverUnderSync=OverUnderSync;const Auth={currentUser:null,authStateListeners:[],waitlistCheckPending:!1,init(){onAuthStateChanged(auth,(async e=>{if(e){const t=window.location.pathname.includes("waitlist.html"),r=window.location.pathname.includes("admin.html")||window.location.pathname.includes("wdhn.html");if(!this.waitlistCheckPending&&!t&&!r){this.waitlistCheckPending=!0;const t=await checkWaitlistAccess(e.uid,e.email);if(this.waitlistCheckPending=!1,!t.approved)return console.log("User not on approved waitlist, redirecting..."),void(window.location.href="waitlist.html")}this.currentUser={uid:e.uid,email:e.email,displayName:e.displayName,photoURL:e.photoURL,isGuest:!1},await UserData.loadFromFirebase(e.uid,{email:e.email,displayName:e.displayName,photoURL:e.photoURL}),console.log("User signed in:",e.displayName)}else this.currentUser=null,UserData.data=null,UserData.userId=null,console.log("User signed out");this.authStateListeners.forEach((e=>e(this.currentUser)))}))},async signInWithGoogle(){try{const e=await signInWithPopup(auth,googleProvider);if(!window.location.pathname.includes("waitlist.html")){if(!(await checkWaitlistAccess(e.user.uid,e.user.email)).approved)return window.location.href="waitlist.html",{success:!0,user:e.user,waitlist:!0}}return{success:!0,user:e.user}}catch(e){return console.error("Sign in error:",e),{success:!1,error:e.message}}},async signOut(){try{return await signOut(auth),this.currentUser=null,{success:!0}}catch(e){return console.error("Sign out error:",e),{success:!1,error:e.message}}},isSignedIn(){return null!==this.currentUser&&!this.currentUser.isGuest},getUser(){return this.currentUser},onAuthStateChange(e){this.authStateListeners.push(e),void 0!==this.currentUser&&e(this.currentUser)},setGuestMode(){this.currentUser={uid:"guest_"+Date.now(),displayName:"Guest",isGuest:!0},this.authStateListeners.forEach((e=>e(this.currentUser)))}};window.Auth=Auth;const UserData={data:null,userId:null,getDefault:(e={})=>({email:e.email||null,displayName:e.displayName||null,photoURL:e.photoURL||null,balance:500,keys:40,positions:[],watchlist:[],transactions:[],cashOuts:[],createdAt:(new Date).toISOString(),lastLoginAt:(new Date).toISOString()}),async loadFromFirebase(e,t={}){this.userId=e;try{const r=await getDoc(doc(usersRef,e));r.exists()?(this.data=r.data(),this.data.email=t.email||this.data.email,this.data.displayName=t.displayName||this.data.displayName,this.data.photoURL=t.photoURL||this.data.photoURL,this.data.lastLoginAt=(new Date).toISOString(),void 0===this.data.keys&&(this.data.keys=40),await this.save()):(this.data=this.getDefault(t),await setDoc(doc(usersRef,e),this.data),console.log("Created new user document for:",e))}catch(e){console.error("Error loading user data:",e),this.data=this.getDefault(t)}return this.data},async save(){if(this.userId&&this.data)try{await setDoc(doc(usersRef,this.userId),this.data)}catch(e){console.error("Error saving user data:",e)}},get(){return this.data||this.getDefault()},getBalance(){return this.get().balance},getKeys(){return this.get().keys||0},async updateKeys(e){return this.data?(this.data.keys=Math.max(0,(this.data.keys||0)+e),await this.save(),this.data.keys):0},STREAK_MULTIPLIERS:[1,1.2,1.4,1.7,2,2.4,2.8,3.2,3.6,4],BASE_KEY_REWARD:4,BASE_BALANCE_REWARD:150,getStreakMultiplier(e){const t=Math.min(e-1,this.STREAK_MULTIPLIERS.length-1);return t<0?this.STREAK_MULTIPLIERS[0]:this.STREAK_MULTIPLIERS[t]},getLastDailyKeyClaim(){return this.get().lastDailyKeyClaim||null},getDailyStreak(){return this.get().dailyStreak||0},canClaimDailyKey(){const e=this.getLastDailyKeyClaim();if(!e)return!0;const t=new Date(e).getTime();return(Date.now()-t)/36e5>=24},isStreakValid(){const e=this.getLastDailyKeyClaim();if(!e)return!1;const t=new Date(e).getTime();return(Date.now()-t)/36e5<48},getTimeUntilNextClaim(){const e=this.getLastDailyKeyClaim();if(!e)return 0;const t=new Date(e).getTime()+864e5,r=Date.now();return Math.max(0,t-r)},getStreakRewardInfo(){let e=this.getDailyStreak();!this.isStreakValid()&&e>0&&(e=0);const t=e+1,r=this.getStreakMultiplier(t);return{currentStreak:e,nextStreak:t,multiplier:r,keysReward:Math.floor(this.BASE_KEY_REWARD*r),balanceReward:Math.floor(this.BASE_BALANCE_REWARD*r)}},async claimDailyKey(){if(!this.data)return{success:!1,error:"Not signed in"};if(!this.canClaimDailyKey())return{success:!1,error:"Already claimed today"};try{let e=1;this.isStreakValid()&&(e=(this.data.dailyStreak||0)+1);const t=this.getStreakMultiplier(e),r=Math.floor(this.BASE_KEY_REWARD*t),s=Math.floor(this.BASE_BALANCE_REWARD*t);return this.data.keys=(this.data.keys||0)+r,this.data.balance=Math.round(100*((this.data.balance||0)+s))/100,this.data.dailyStreak=e,this.data.lastDailyKeyClaim=(new Date).toISOString(),await this.save(),{success:!0,keys:this.data.keys,balance:this.data.balance,keysReward:r,balanceReward:s,streak:e,multiplier:t}}catch(e){return console.error("Error claiming daily reward:",e),{success:!1,error:e.message}}},async updateProfile(e,t){if(!this.data)return{success:!1,error:"Not signed in"};try{return void 0!==e&&""!==e.trim()&&(this.data.displayName=e.trim(),this.data.customUserName=e.trim()),void 0!==t&&(this.data.avatarStyle=t),await this.save(),{success:!0}}catch(e){return console.error("Error updating profile:",e),{success:!1,error:e.message}}},getAvatarStyle(){return this.get().avatarStyle||"default"},getDisplayName(){return this.get().displayName||"Anonymous"},async updateBalance(e){return this.data?(this.data.balance=Math.round(100*(this.data.balance+e))/100,await this.save(),this.data.balance):0},async addPosition(e,t,r,s,a,o){if(!this.data)return[];const i="trade_"+Date.now()+"_"+Math.random().toString(36).substr(2,9),n=(new Date).toISOString(),c=this.data.positions.findIndex((t=>t.marketId===e&&t.choice===r));if(-1!==c){const e=this.data.positions[c];e.shares+=s,e.costBasis+=a,e.avgPrice=Math.round(e.costBasis/e.shares*100)/100,e.tradeIds=e.tradeIds||[],e.tradeIds.push(i)}else this.data.positions.push({marketId:e,marketTitle:t,choice:r,shares:s,costBasis:a,avgPrice:o,purchaseDate:n,tradeIds:[i]});this.data.transactions=this.data.transactions||[],this.data.transactions.unshift({type:"buy",marketId:e,choice:r,shares:s,price:o,cost:a,tradeId:i,timestamp:n}),await this.save();try{await setDoc(doc(positionsRef,i),{tradeId:i,userId:this.userId,marketId:e,marketTitle:t,choice:r,shares:s,costBasis:a,price:o,timestamp:n,status:"active"})}catch(e){console.warn("Could not save to central positions collection:",e)}return this.data.positions},getPositions(){return this.get().positions||[]},async sellPosition(e,t,r,s){if(!this.data)return null;const a=this.data.positions.findIndex((r=>r.marketId===e&&r.choice===t));if(-1===a)return null;const o=this.data.positions[a],i=o.costBasis/o.shares*r;return r>=o.shares?this.data.positions.splice(a,1):(o.shares-=r,o.costBasis-=i),this.data.transactions=this.data.transactions||[],this.data.transactions.unshift({type:"sell",marketId:e,choice:t,shares:r,price:Math.round(s/r*100),proceeds:s,profit:s-i,timestamp:(new Date).toISOString()}),await this.save(),{soldCostBasis:i,profit:s-i}},getPosition(e){return this.getPositions().find((t=>t.marketId===e))||null},getWatchlist(){return this.get().watchlist||[]},getCashOuts(){return this.get().cashOuts||[]},getSeenCashoutIds(){return this.get().seenCashoutIds||[]},getUnseenWins(){const e=this.getCashOuts(),t=this.getSeenCashoutIds();return e.filter((e=>e.won&&!t.includes(e.marketId+"_"+e.timestamp)))},async markCashoutsAsSeen(e){this.data&&(this.data.seenCashoutIds||(this.data.seenCashoutIds=[]),this.data.seenCashoutIds=[...new Set([...this.data.seenCashoutIds,...e])],await this.save())},async addToWatchlist(e){return this.data?(this.data.watchlist.includes(e)||(this.data.watchlist.push(e),await this.save()),this.data.watchlist):[]},async removeFromWatchlist(e){return this.data?(this.data.watchlist=this.data.watchlist.filter((t=>t!==e)),await this.save(),this.data.watchlist):[]},isWatchlisted(e){return(this.get().watchlist||[]).includes(e)},async reset(){this.data=this.getDefault(),await this.save()}};window.UserData=UserData;const OnboardingState={STORAGE_KEY:"mulon_onboarding",hasCompletedOnboarding(){return"completed"===localStorage.getItem(this.STORAGE_KEY)},setCompleted(){localStorage.setItem(this.STORAGE_KEY,"completed")},reset(){localStorage.removeItem(this.STORAGE_KEY)}};window.OnboardingState=OnboardingState;const OrderBook={books:{},async initBook(e){if(!this.books[e])try{const t=await getDoc(doc(db,"mulon_orderbooks",e));t.exists()?this.books[e]=t.data():(this.books[e]=this.createEmptyBook(),await this.saveOrderBook(e))}catch(t){console.warn("Could not load order book from Firebase:",t),this.books[e]=this.createEmptyBook()}return this.books[e]},createEmptyBook:()=>({yes:{bids:[],asks:[]},no:{bids:[],asks:[]},lastUpdated:(new Date).toISOString(),totalOrders:0,matchedOrders:0}),async saveOrderBook(e){try{const t=this.books[e];t&&(t.lastUpdated=(new Date).toISOString(),await setDoc(doc(db,"mulon_orderbooks",e),t))}catch(e){console.warn("Could not save order book to Firebase:",e)}},async addLimitOrder(e,t,r,s,a,o="anonymous"){const i=await this.initBook(e),n={orderId:"order_"+Date.now()+"_"+Math.random().toString(36).substr(2,9),price:Math.round(s),quantity:Math.round(100*a)/100,side:t,choice:r,userId:o,timestamp:(new Date).toISOString(),status:"open",filled:0},c=i[r];return"buy"===t?(c.bids.push(n),c.bids.sort(((e,t)=>t.price-e.price))):(c.asks.push(n),c.asks.sort(((e,t)=>e.price-t.price))),i.totalOrders++,await this.saveOrder(n),await this.saveOrderBook(e),await this.matchOrders(e,r),n},async saveOrder(e){try{await setDoc(doc(ordersRef,e.orderId),e)}catch(e){console.warn("Could not save order to Firebase:",e)}},async updateOrderStatus(e,t){try{await updateDoc(doc(ordersRef,e),t)}catch(e){console.warn("Could not update order:",e)}},async matchOrders(e,t){const r=await this.initBook(e),s=r[t];for(;s.bids.length>0&&s.asks.length>0;){const a=s.bids[0],o=s.asks[0];if(!(a.price>=o.price))break;{const i=Math.round((a.price+o.price)/2),n=Math.min(a.quantity-a.filled,o.quantity-o.filled),c={id:"trade_"+Date.now(),marketId:e,choice:t,buyOrderId:a.orderId,sellOrderId:o.orderId,price:i,quantity:n,timestamp:(new Date).toISOString()};await this.saveTrade(c),a.filled+=n,o.filled+=n,a.filled>=a.quantity&&(a.status="filled",s.bids.shift(),await this.updateOrderStatus(a.orderId,{status:"filled",filled:a.filled})),o.filled>=o.quantity&&(o.status="filled",s.asks.shift(),await this.updateOrderStatus(o.orderId,{status:"filled",filled:o.filled})),r.matchedOrders++,await this.updateMarketPrice(e,t,i)}}await this.saveOrderBook(e)},async updateMarketPrice(e,t,r){if(!MulonData.getMarket(e))return;let s;s="yes"===t?{yesPrice:r,noPrice:100-r}:{noPrice:r,yesPrice:100-r},await MulonData.updateMarket(e,s)},async executeMarketOrder(e,t,r,s,a="anonymous"){await this.initBook(e);const o=MulonData.getMarket(e);if(!o)return{filled:!1,error:"Market not found"};const i="yes"===r?o.yesPrice:o.noPrice,n=s/(i/100),c=o.volume||1e3,d=Math.min(s/c,.15);let l,u;"buy"===t?"yes"===r?(l=Math.min(99,Math.round(o.yesPrice+100*d)),u=100-l):(u=Math.min(99,Math.round(o.noPrice+100*d)),l=100-u):"yes"===r?(l=Math.max(1,Math.round(o.yesPrice-100*d)),u=100-l):(u=Math.max(1,Math.round(o.noPrice-100*d)),l=100-u);const h={yesPrice:l,noPrice:u,volume:(o.volume||0)+Math.round(s)};await MulonData.updateMarket(e,h);const g={id:"trade_"+Date.now(),marketId:e,side:t,choice:r,shares:Math.round(100*n)/100,price:i,cost:s,priceAfter:"yes"===r?l:u,userId:a,orderType:"market",timestamp:(new Date).toISOString()};return await this.saveTrade(g),await this.updateOrderBookFromTrade(e,g),{filled:!0,shares:g.shares,avgPrice:i,cost:s,newPrice:"yes"===r?l:u,priceChange:("yes"===r?l:u)-i}},async updateOrderBookFromTrade(e,t){const r=await this.initBook(e);r.recentTrades||(r.recentTrades=[]),r.recentTrades.unshift({price:t.price,shares:t.shares,side:t.side,timestamp:t.timestamp}),r.recentTrades.length>50&&(r.recentTrades=r.recentTrades.slice(0,50)),await this.saveOrderBook(e)},async saveTrade(e){try{await setDoc(doc(tradesRef,e.id),e)}catch(e){console.warn("Could not save trade to Firebase:",e)}},async getRecentTrades(e,t=20){try{const r=await getDocs(tradesRef),s=[];return r.forEach((t=>{const r=t.data();r.marketId===e&&s.push(r)})),s.sort(((e,t)=>new Date(t.timestamp)-new Date(e.timestamp))),0===t?s:s.slice(0,t)}catch(e){return console.warn("Could not fetch trades:",e),[]}},async getOrderBook(e){return await this.initBook(e)},async getOpenOrders(e){const t=await this.initBook(e);return{yes:{bids:t.yes.bids.filter((e=>"open"===e.status)),asks:t.yes.asks.filter((e=>"open"===e.status))},no:{bids:t.no.bids.filter((e=>"open"===e.status)),asks:t.no.asks.filter((e=>"open"===e.status))}}},async cancelOrder(e,t){const r=await this.initBook(e);for(const s of["yes","no"])for(const a of["bids","asks"]){const o=r[s][a].findIndex((e=>e.orderId===t));if(-1!==o)return r[s][a][o].status="cancelled",r[s][a].splice(o,1),await this.updateOrderStatus(t,{status:"cancelled"}),await this.saveOrderBook(e),!0}return!1},getProbability:e=>e,async getSpread(e,t){const r=await this.initBook(e),s=MulonData.getMarket(e);if(!s)return null;const a=r[t],o=a.bids[0],i=a.asks[0],n="yes"===t?s.yesPrice:s.noPrice;return{bid:o?o.price:Math.max(1,n-1),ask:i?i.price:Math.min(99,n+1),mid:n,bidQuantity:o?o.quantity-o.filled:0,askQuantity:i?i.quantity-i.filled:0}},async getDepth(e,t,r=5){const s=(await this.initBook(e))[t],a=e=>{const t={};return e.forEach((e=>{t[e.price]||(t[e.price]=0),t[e.price]+=e.quantity-e.filled})),Object.entries(t).map((([e,t])=>({price:parseInt(e),quantity:t})))};return{bids:a(s.bids).slice(0,r),asks:a(s.asks).slice(0,r)}}};window.OrderBook=OrderBook;const MulonData={STORAGE_KEY:"mulon_markets",isInitialized:!1,cachedMarkets:[],defaultMarkets:[{id:"market_1",title:"When will Torre grade the next exam?",subtitle:"Will Mr. Torre post grades before February 1st?",category:"grading",categoryIcon:"ðŸ“",categoryLabel:"Grading",yesPrice:69,noPrice:31,volume:2400,startDate:"2026-01-15",endDate:"2026-02-01",status:"active",featured:!0,createdAt:"2026-01-15T10:00:00Z",totalShares:{yes:2400,no:1100},orderBookId:"market_1"},{id:"market_2",title:"Will the basketball team win Friday's game?",subtitle:"Tech High vs Central High",category:"sports",categoryIcon:"âš½",categoryLabel:"Sports",yesPrice:45,noPrice:55,volume:1200,startDate:"2026-01-20",endDate:"2026-01-24",status:"active",featured:!1,createdAt:"2026-01-20T09:00:00Z",totalShares:{yes:540,no:660},orderBookId:"market_2"},{id:"market_3",title:"Will the cafeteria serve pizza on Monday?",subtitle:"Weekly menu prediction",category:"school",categoryIcon:"ðŸŽ“",categoryLabel:"Tech High",yesPrice:82,noPrice:18,volume:850,startDate:"2026-01-21",endDate:"2026-01-27",status:"active",featured:!1,createdAt:"2026-01-21T08:00:00Z",totalShares:{yes:697,no:153},orderBookId:"market_3"},{id:"market_4",title:"Will student council approve the new club?",subtitle:"Gaming Club proposal vote",category:"politics",categoryIcon:"ðŸ›ï¸",categoryLabel:"Politics",yesPrice:58,noPrice:42,volume:640,startDate:"2026-01-18",endDate:"2026-02-01",status:"active",featured:!1,createdAt:"2026-01-18T14:00:00Z",totalShares:{yes:371,no:269},orderBookId:"market_4"},{id:"market_5",title:"Will class average exceed 85% on final?",subtitle:"AP Chemistry final exam",category:"grading",categoryIcon:"ðŸ“",categoryLabel:"Grading",yesPrice:34,noPrice:66,volume:920,startDate:"2026-01-10",endDate:"2026-02-15",status:"active",featured:!1,createdAt:"2026-01-10T11:00:00Z",totalShares:{yes:313,no:607},orderBookId:"market_5"}],categories:{},defaultCategories:{school:{icon:"ðŸŽ“",label:"Tech High",color:"school"},sports:{icon:"âš½",label:"Sports",color:"sports"},politics:{icon:"ðŸ›ï¸",label:"Politics",color:"politics"},grading:{icon:"ðŸ“",label:"Grading",color:"grading"}},async fetchCategories(){try{const e=await getDocs(categoriesRef),t={};return e.forEach((e=>{t[e.id]=e.data()})),0===Object.keys(t).length?(console.log("No categories in Firebase, initializing with defaults..."),await this.initializeCategoriesWithDefaults(),this.categories={...this.defaultCategories}):this.categories=t,this.categories}catch(e){return console.error("Error fetching categories:",e),this.categories={...this.defaultCategories},this.categories}},async initializeCategoriesWithDefaults(){try{for(const[e,t]of Object.entries(this.defaultCategories))await setDoc(doc(categoriesRef,e),t);console.log("Categories initialized in Firebase")}catch(e){console.error("Error initializing categories:",e)}},async addCategory(e,t,r,s){requireAdmin();try{const a={icon:t,label:r,color:s||e};return await setDoc(doc(categoriesRef,e),a),this.categories[e]=a,console.log("Category added:",e),{success:!0,category:a}}catch(e){return console.error("Error adding category:",e),{success:!1,error:e.message}}},async updateCategory(e,t){requireAdmin();try{return await updateDoc(doc(categoriesRef,e),t),this.categories[e]={...this.categories[e],...t},console.log("Category updated:",e),{success:!0}}catch(e){return console.error("Error updating category:",e),{success:!1,error:e.message}}},async deleteCategory(e){requireAdmin();try{return await deleteDoc(doc(categoriesRef,e)),delete this.categories[e],console.log("Category deleted:",e),{success:!0}}catch(e){return console.error("Error deleting category:",e),{success:!1,error:e.message}}},getCategories(){return this.categories},getCategory(e){return this.categories[e]||{icon:"ðŸ“Š",label:"Other",color:"other"}},async submitSuggestion(e,t,r,s,a,o){try{const i=auth.currentUser;if(i){if(i.email){const e=i.email.toLowerCase().replace(/[.#$[\]]/g,"_");if((await getDoc(doc(bannedEmailsRef,e))).exists())return console.log("Banned user attempted to submit suggestion"),{success:!1,error:"You are banned from submitting suggestions."}}const e=await getDoc(doc(usersRef,i.uid));if(e.exists()&&!0===e.data().banned)return console.log("Banned user attempted to submit suggestion"),{success:!1,error:"You are banned from submitting suggestions."}}const n="sug_"+Date.now(),c={id:n,title:e,category:t||null,reason:r||"",userId:s||null,userEmail:a||"Anonymous",userName:o||"Anonymous",status:"pending",createdAt:(new Date).toISOString()};return await setDoc(doc(suggestionsRef,n),c),console.log("Suggestion submitted:",n),{success:!0,id:n}}catch(e){return console.error("Error submitting suggestion:",e),{success:!1,error:e.message}}},async getSuggestions(){try{const e=await getDocs(suggestionsRef),t=[];return e.forEach((e=>{t.push({id:e.id,...e.data()})})),t.sort(((e,t)=>new Date(t.createdAt)-new Date(e.createdAt))),t}catch(e){return console.error("Error fetching suggestions:",e),[]}},async updateSuggestionStatus(e,t){requireAdmin();try{return await updateDoc(doc(suggestionsRef,e),{status:t}),{success:!0}}catch(e){return console.error("Error updating suggestion:",e),{success:!1,error:e.message}}},async deleteSuggestion(e){requireAdmin();try{return await deleteDoc(doc(suggestionsRef,e)),{success:!0}}catch(e){return console.error("Error deleting suggestion:",e),{success:!1,error:e.message}}},async init(){if(this.isInitialized)return this.cachedMarkets;try{await this.fetchCategories();const e=await this.fetchMarketsFromFirebase();return 0===e.length?(console.log("No markets in Firebase, initializing with defaults..."),await this.initializeFirebaseWithDefaults(),this.cachedMarkets=this.defaultMarkets):this.cachedMarkets=e,this.isInitialized=!0,this.cachedMarkets}catch(e){return console.error("Error initializing MulonData:",e),this.cachedMarkets=this.defaultMarkets,this.cachedMarkets}},async fetchMarketsFromFirebase(){try{const e=await getDocs(marketsRef),t=[];return e.forEach((e=>{t.push({id:e.id,...e.data()})})),t}catch(e){return console.error("Error fetching markets from Firebase:",e),[]}},async initializeFirebaseWithDefaults(){try{for(const e of this.defaultMarkets)await setDoc(doc(marketsRef,e.id),e);console.log("Firebase initialized with default markets")}catch(e){console.error("Error initializing Firebase with defaults:",e)}},async transferFromLocalStorage(){const e=localStorage.getItem(this.STORAGE_KEY);if(!e)return console.log("No localStorage data to transfer"),!1;try{const t=JSON.parse(e);console.log(`Transferring ${t.length} markets to Firebase...`);for(const e of t)await setDoc(doc(marketsRef,e.id),e),console.log(`Transferred: ${e.title}`);return console.log("Transfer complete!"),!0}catch(e){return console.error("Error transferring to Firebase:",e),!1}},async getMarkets(){return this.isInitialized||await this.init(),this.cachedMarkets},getMarketsSync(){return this.cachedMarkets},async refreshMarkets(){return this.cachedMarkets=await this.fetchMarketsFromFirebase(),this.cachedMarkets},async addMarket(e){requireAdmin();const t={id:"market_"+Date.now(),...e,createdAt:(new Date).toISOString(),status:"active",totalShares:{yes:0,no:0},orderBookId:"market_"+Date.now()};try{return await setDoc(doc(marketsRef,t.id),t),await OrderBook.initBook(t.id),this.cachedMarkets.push(t),console.log("Market added:",t.title),t}catch(e){return console.error("Error adding market:",e),null}},async updateMarket(e,t){requireAdmin();try{const r=doc(marketsRef,e);await updateDoc(r,t);const s=this.cachedMarkets.findIndex((t=>t.id===e));return-1!==s&&(this.cachedMarkets[s]={...this.cachedMarkets[s],...t}),console.log("Market updated:",e),this.cachedMarkets[s]}catch(e){return console.error("Error updating market:",e),null}},async resolveMarket(e,t){requireAdmin();try{const r=this.getMarket(e);if(!r)return{success:!1,error:"Market not found"};if(r.resolved)return{success:!1,error:"Market already resolved"};const s=await getDocs(usersRef);let a=0;const o=[];for(const i of s.docs){const s=i.data(),n=s.positions||[],c=n.filter((t=>t.marketId===e));if(c.length>0){let d=0;const l=n.filter((t=>t.marketId!==e)),u=[];for(const s of c){const o=s.choice===t,i=o?s.shares:0;u.push({marketId:e,marketTitle:r.title,position:s.choice,shares:s.shares,avgPrice:s.avgPrice||Math.round(s.costBasis/s.shares*100)/100,cost:s.costBasis,outcome:t,won:o,payout:i,timestamp:(new Date).toISOString()}),o&&(d+=i,a++)}const h=s.cashOuts||[],g=(s.balance||0)+d,m=u.some((e=>e.won)),f=s.keys||0,p={positions:l,balance:Math.round(100*g)/100,cashOuts:[...h,...u]};m&&(p.keys=f+10),await updateDoc(doc(usersRef,i.id),p),o.push(...u)}}return await this.updateMarket(e,{resolved:!0,resolvedOutcome:t,resolvedAt:(new Date).toISOString()}),console.log(`Market ${e} resolved as ${t}. ${a} winning positions paid out.`),{success:!0,payoutCount:a,cashOuts:o}}catch(e){return console.error("Error resolving market:",e),{success:!1,error:e.message}}},async deleteMarket(e){requireAdmin();try{return await deleteDoc(doc(marketsRef,e)),this.cachedMarkets=this.cachedMarkets.filter((t=>t.id!==e)),console.log("Market deleted:",e),this.cachedMarkets}catch(e){return console.error("Error deleting market:",e),this.cachedMarkets}},getMarket(e){return this.cachedMarkets.find((t=>t.id===e))},async getMarketFromFirebase(e){try{const t=await getDoc(doc(marketsRef,e));return t.exists()?{id:t.id,...t.data()}:null}catch(e){return console.error("Error fetching market:",e),null}},getMarketsByCategory(e){return"all"===e?this.cachedMarkets:this.cachedMarkets.filter((t=>t.category===e))},getFeaturedMarkets(){return this.cachedMarkets.filter((e=>e.featured))},getActiveMarkets(){return this.cachedMarkets.filter((e=>"active"===e.status))},formatVolume:e=>e>=1e3?"$"+(e/1e3).toFixed(1)+"k Vol.":"$"+e+" Vol.",formatDate:e=>new Date(e).toLocaleDateString("en-US",{month:"short",day:"numeric"}),getDaysUntil(e){const t=new Date(e),r=new Date,s=Math.ceil((t-r)/864e5);return s<=0?"Ended":1===s?"Ends tomorrow":`Ends in ${s} days`},async resetToDefaults(){requireAdmin();try{const e=await getDocs(marketsRef),t=[];return e.forEach((e=>{t.push(deleteDoc(doc(marketsRef,e.id)))})),await Promise.all(t),await this.initializeFirebaseWithDefaults(),this.cachedMarkets=[...this.defaultMarkets],console.log("Reset to defaults complete"),this.cachedMarkets}catch(e){return console.error("Error resetting to defaults:",e),this.cachedMarkets}},async getMarketTradesWithUsers(e){try{const t=await getDocs(tradesRef),r=[],s=new Set;t.forEach((t=>{const a=t.data();a.marketId===e&&(r.push(a),a.userId&&s.add(a.userId))})),r.sort(((e,t)=>new Date(t.timestamp)-new Date(e.timestamp)));const a={};for(const e of s)try{const t=await getDoc(doc(usersRef,e));if(t.exists()){const r=t.data();a[e]={displayName:r.displayName||"Anonymous",email:r.email||"Unknown",photoURL:r.photoURL||null}}else a[e]={displayName:"Unknown User",email:"N/A",photoURL:null}}catch(t){a[e]={displayName:"Unknown User",email:"N/A",photoURL:null}}return r.map((e=>({...e,user:a[e.userId]||{displayName:"Guest",email:"N/A",photoURL:null}})))}catch(e){return console.error("Error fetching market trades with users:",e),[]}},async getMarketPositions(e){try{const t=await getDocs(usersRef),r=[];for(const s of t.docs){const t=s.data(),a=(t.positions||[]).find((t=>t.marketId===e));a&&r.push({userId:s.id,displayName:t.displayName||"Anonymous",email:t.email||"Unknown",photoURL:t.photoURL||null,...a})}return r.sort(((e,t)=>t.shares-e.shares)),r}catch(e){return console.error("Error fetching market positions:",e),[]}},async getAllUsers(){try{const e=await getDocs(usersRef),t=[];for(const r of e.docs){const e=r.data();let s=[];try{const e=collection(db,"mulon_users",r.id,"card_inventory"),t=query(e,where("hasCard","==",!0));(await getDocs(t)).forEach((e=>{s.push({docId:e.id,...e.data()})}))}catch(t){console.warn(`Error loading cards for user ${r.id}:`,t),s=e.ownedCards||[]}t.push({id:r.id,displayName:e.displayName||"Anonymous",email:e.email||"Unknown",photoURL:e.photoURL||null,keys:e.keys||0,balance:e.balance||0,positions:e.positions||[],ownedCards:s,createdAt:e.createdAt||null,lastLoginAt:e.lastLoginAt||null,banned:e.banned||!1,bannedAt:e.bannedAt||null,bannedReason:e.bannedReason||null})}return t.sort(((e,t)=>t.balance-e.balance)),t}catch(e){return console.error("Error fetching all users:",e),[]}},async updateUserBalance(e,t){requireAdmin();try{const r=await getDoc(doc(usersRef,e)),s=r.exists()&&r.data().balance||0,a=r.exists()?r.data():{},o=Math.round(100*t)/100;return await updateDoc(doc(usersRef,e),{balance:o}),await logAdminAction("balance_update",{targetUserId:e,targetUserEmail:a.email||null,targetUserName:a.displayName||null,beforeValue:s,afterValue:o}),{success:!0}}catch(e){return console.error("Error updating user balance:",e),{success:!1,error:e.message}}},async updateUserKeys(e,t){requireAdmin();try{const r=await getDoc(doc(usersRef,e)),s=r.exists()&&r.data().keys||0,a=r.exists()?r.data():{},o=Math.max(0,Math.round(t));return await updateDoc(doc(usersRef,e),{keys:o}),await logAdminAction("keys_update",{targetUserId:e,targetUserEmail:a.email||null,targetUserName:a.displayName||null,beforeValue:s,afterValue:o}),{success:!0}}catch(e){return console.error("Error updating user keys:",e),{success:!1,error:e.message}}},async bulkUpdateKeys(e,t="add"){requireAdmin();try{const r=await getDocs(usersRef);let s=0;for(const a of r.docs){const r=a.data().keys||0;let o;"set"===t?o=e:"add"===t?o=r+e:"subtract"===t?o=Math.max(0,r-e):"multiply"===t&&(o=r*e),o=Math.max(0,Math.round(o)),await updateDoc(doc(usersRef,a.id),{keys:o}),s++}return await logAdminAction("bulk_keys_update",{operation:t,amount:e,usersAffected:s}),{success:!0,updatedCount:s}}catch(e){return console.error("Error bulk updating keys:",e),{success:!1,error:e.message}}},async adjustUserBalance(e,t){requireAdmin();try{const r=await getDoc(doc(usersRef,e));if(!r.exists())return{success:!1,error:"User not found"};const s=r.data().balance||0,a=Math.round(100*(s+t))/100;return await updateDoc(doc(usersRef,e),{balance:a}),{success:!0,newBalance:a}}catch(e){return console.error("Error adjusting user balance:",e),{success:!1,error:e.message}}},async bulkUpdateBalances(e,t="add"){requireAdmin();try{const r=await getDocs(usersRef);let s=0;for(const a of r.docs){const r=a.data().balance||0;let o;"set"===t?o=e:"add"===t?o=r+e:"subtract"===t?o=Math.max(0,r-e):"multiply"===t&&(o=r*e),o=Math.round(100*o)/100,await updateDoc(doc(usersRef,a.id),{balance:o}),s++}return await logAdminAction("bulk_balance_update",{operation:t,amount:e,usersAffected:s}),{success:!0,updatedCount:s}}catch(e){return console.error("Error bulk updating balances:",e),{success:!1,error:e.message}}},async resetUserPositions(e){requireAdmin();try{const t=await getDoc(doc(usersRef,e));if(!t.exists())return{success:!1,error:"User not found"};const r=t.data(),s=r.positions||[],a=s.length;for(const e of s){const t=Math.round(e.costBasis||0);if(t>0){const r=this.getMarket(e.marketId);if(r){const s=Math.max(0,(r.volume||0)-t);await this.updateMarket(e.marketId,{volume:s})}}if(e.tradeIds)for(const t of e.tradeIds)try{await deleteDoc(doc(positionsRef,t)),await deleteDoc(doc(tradesRef,t))}catch(e){console.warn("Could not delete position/trade:",t)}}return await updateDoc(doc(usersRef,e),{positions:[]}),await logAdminAction("user_positions_reset",{targetUserId:e,targetUserEmail:r.email||null,targetUserName:r.displayName||null,positionsDeleted:a}),{success:!0}}catch(e){return console.error("Error resetting user positions:",e),{success:!1,error:e.message}}},async resetAllUsersPositions(){requireAdmin();try{const e=await getDocs(usersRef);let t=0;const r={};for(const s of e.docs){const e=s.data().positions||[];for(const t of e){const e=Math.round(t.costBasis||0);if(e>0&&(r[t.marketId]=(r[t.marketId]||0)+e),t.tradeIds)for(const e of t.tradeIds)try{await deleteDoc(doc(positionsRef,e)),await deleteDoc(doc(tradesRef,e))}catch(t){console.warn("Could not delete position/trade:",e)}}await updateDoc(doc(usersRef,s.id),{positions:[]}),t++}for(const[e,t]of Object.entries(r)){const r=this.getMarket(e);if(r){const s=Math.max(0,(r.volume||0)-t);await this.updateMarket(e,{volume:s})}}return{success:!0,resetCount:t}}catch(e){return console.error("Error resetting all positions:",e),{success:!1,error:e.message}}},async resetUser(e,t=500){requireAdmin();try{return await updateDoc(doc(usersRef,e),{balance:t,positions:[]}),{success:!0}}catch(e){return console.error("Error resetting user:",e),{success:!1,error:e.message}}},async resetAllUsers(e=500){requireAdmin();try{const t=await getDocs(usersRef);let r=0;for(const s of t.docs)await updateDoc(doc(usersRef,s.id),{balance:e,positions:[]}),r++;return{success:!0,resetCount:r}}catch(e){return console.error("Error resetting all users:",e),{success:!1,error:e.message}}},async addCardToUser(e,t){requireAdmin();try{const r=await getDoc(doc(usersRef,e));if(!r.exists())return{success:!1,error:"User not found"};const s=r.data(),a={cardNumber:t.cardNumber,hasCard:!0,addedAt:(new Date).toISOString(),addedBy:"admin",obtainedFrom:"admin"},o=collection(db,"mulon_users",e,"card_inventory");return await addDoc(o,a),await logAdminAction("card_added",{targetUserId:e,targetUserEmail:s.email||null,targetUserName:s.displayName||null,cardNumber:t.cardNumber}),{success:!0}}catch(e){return console.error("Error adding card to user:",e),{success:!1,error:e.message}}},async removeCardFromUser(e,t){requireAdmin();try{const r=await getDoc(doc(usersRef,e));if(!r.exists())return{success:!1,error:"User not found"};const s=r.data(),a=collection(db,"mulon_users",e,"card_inventory"),o=query(a,where("cardNumber","==",t),where("hasCard","==",!0)),i=await getDocs(o);if(i.empty)return{success:!1,error:"Card not found"};const n=i.docs[0];return await updateDoc(doc(db,"mulon_users",e,"card_inventory",n.id),{hasCard:!1,removedAt:(new Date).toISOString(),removedBy:"admin"}),await logAdminAction("card_removed",{targetUserId:e,targetUserEmail:s.email||null,targetUserName:s.displayName||null,cardNumber:t}),{success:!0}}catch(e){return console.error("Error removing card from user:",e),{success:!1,error:e.message}}},async resetUserCards(e){requireAdmin();try{const t=await getDoc(doc(usersRef,e));if(!t.exists())return{success:!1,error:"User not found"};const r=t.data(),s=collection(db,"mulon_users",e,"card_inventory"),a=query(s,where("hasCard","==",!0)),o=await getDocs(a),i=o.size;for(const t of o.docs)await updateDoc(doc(db,"mulon_users",e,"card_inventory",t.id),{hasCard:!1,removedAt:(new Date).toISOString(),removedBy:"admin_reset"});return await logAdminAction("user_cards_reset",{targetUserId:e,targetUserEmail:r.email||null,targetUserName:r.displayName||null,cardsDeleted:i}),{success:!0}}catch(e){return console.error("Error resetting user cards:",e),{success:!1,error:e.message}}},async resetAllUsersCards(){requireAdmin();try{const e=await getDocs(usersRef);let t=0,r=0;for(const s of e.docs){const e=collection(db,"mulon_users",s.id,"card_inventory"),a=query(e,where("hasCard","==",!0)),o=await getDocs(a);r+=o.size;for(const e of o.docs)await updateDoc(doc(db,"mulon_users",s.id,"card_inventory",e.id),{hasCard:!1,removedAt:(new Date).toISOString(),removedBy:"admin_bulk_reset"});o.size>0&&t++}return await logAdminAction("all_cards_reset",{usersAffected:t,totalCardsDeleted:r}),{success:!0,resetCount:t,totalCardsDeleted:r}}catch(e){return console.error("Error resetting all user cards:",e),{success:!1,error:e.message}}},async bulkAddCardToAllUsers(e){requireAdmin();try{const t=await getDocs(usersRef);let r=0;for(const s of t.docs){const t={cardNumber:e.cardNumber,hasCard:!0,addedAt:(new Date).toISOString(),addedBy:"admin_bulk",obtainedFrom:"admin_bulk"},a=collection(db,"mulon_users",s.id,"card_inventory");await addDoc(a,t),r++}return await logAdminAction("bulk_card_add",{cardNumber:e.cardNumber,usersAffected:r}),{success:!0,updatedCount:r}}catch(e){return console.error("Error bulk adding card:",e),{success:!1,error:e.message}}},async bulkRemoveCardFromAllUsers(e){requireAdmin();try{const t=await getDocs(usersRef);let r=0,s=0;for(const a of t.docs){const t=collection(db,"mulon_users",a.id,"card_inventory"),o=query(t,where("cardNumber","==",e),where("hasCard","==",!0)),i=await getDocs(o);if(!i.empty){for(const e of i.docs)await updateDoc(doc(db,"mulon_users",a.id,"card_inventory",e.id),{hasCard:!1,removedAt:(new Date).toISOString(),removedBy:"admin_bulk"}),s++;r++}}return await logAdminAction("bulk_card_remove",{cardNumber:e,usersAffected:r,cardsRemoved:s}),{success:!0,updatedCount:r,cardsRemoved:s}}catch(e){return console.error("Error bulk removing card:",e),{success:!1,error:e.message}}},async updateUserPosition(e,t,r){requireAdmin();try{const s=await getDoc(doc(usersRef,e));if(!s.exists())return{success:!1,error:"User not found"};const a=s.data().positions||[],o=a.findIndex((e=>e.marketId===t));return-1===o?{success:!1,error:"Position not found"}:(a[o]={...a[o],...r},await updateDoc(doc(usersRef,e),{positions:a}),{success:!0})}catch(e){return console.error("Error updating user position:",e),{success:!1,error:e.message}}},async deleteUserPosition(e,t){requireAdmin();try{const r=await getDoc(doc(usersRef,e));if(!r.exists())return{success:!1,error:"User not found"};const s=r.data().positions||[],a=s.find((e=>e.marketId===t));if(!a)return{success:!1,error:"Position not found"};const o=Math.round(a.costBasis||0),i=s.filter((e=>e.marketId!==t));if(await updateDoc(doc(usersRef,e),{positions:i}),o>0){const e=this.getMarket(t);if(e){const r=Math.max(0,(e.volume||0)-o);await this.updateMarket(t,{volume:r})}}if(a.tradeIds&&a.tradeIds.length>0)for(const e of a.tradeIds)try{await deleteDoc(doc(positionsRef,e)),await deleteDoc(doc(tradesRef,e))}catch(t){console.warn("Could not delete position/trade:",e,t)}try{const r=await getDocs(tradesRef);for(const s of r.docs){const r=s.data();r.userId===e&&r.marketId===t&&await deleteDoc(doc(tradesRef,s.id))}}catch(e){console.warn("Could not clean up related trades:",e)}return{success:!0,volumeRemoved:o}}catch(e){return console.error("Error deleting user position:",e),{success:!1,error:e.message}}},async getUserById(e){try{const t=await getDoc(doc(usersRef,e));if(!t.exists())return null;const r=t.data();return{id:t.id,displayName:r.displayName||"Anonymous",email:r.email||"Unknown",photoURL:r.photoURL||null,balance:r.balance||0,keys:r.keys||0,positions:r.positions||[],createdAt:r.createdAt||null,lastLoginAt:r.lastLoginAt||null,banned:r.banned||!1,bannedAt:r.bannedAt||null,bannedReason:r.bannedReason||null,deviceFingerprints:r.deviceFingerprints||[]}}catch(e){return console.error("Error fetching user:",e),null}},async banUser(e,t="",r=!1){requireAdmin();try{const r=await getDoc(doc(usersRef,e));if(!r.exists())return{success:!1,error:"User not found"};const s=r.data(),a=s.positions||[];for(const e of a)if(e.tradeIds&&e.tradeIds.length>0)for(const t of e.tradeIds)try{await deleteDoc(doc(positionsRef,t)),await deleteDoc(doc(tradesRef,t))}catch(e){console.warn("Could not delete position/trade:",t)}if(await updateDoc(doc(usersRef,e),{banned:!0,bannedAt:(new Date).toISOString(),bannedReason:t||"No reason provided",balance:0,keys:0,positions:[],watchlist:[],cashOuts:[],transactions:[],dailyStreak:0,lastDailyKeyClaim:null}),s.deviceFingerprints&&s.deviceFingerprints.length>0)for(const r of s.deviceFingerprints)await setDoc(doc(bannedDevicesRef,r),{fingerprint:r,bannedAt:(new Date).toISOString(),userId:e,userEmail:s.email||null,reason:t||"No reason provided"});if(s.email){const r=s.email.toLowerCase().replace(/[.#$[\]]/g,"_");await setDoc(doc(bannedEmailsRef,r),{email:s.email.toLowerCase(),bannedAt:(new Date).toISOString(),userId:e,displayName:s.displayName||null,reason:t||"No reason provided",permanent:!0})}return await logAdminAction("user_banned",{targetUserId:e,targetUserEmail:s.email||null,targetUserName:s.displayName||null,reason:t||"No reason provided",deviceBanned:!0,devicesAffected:s.deviceFingerprints?.length||0,positionsCleared:a.length,balanceCleared:s.balance||0,keysCleared:s.keys||0}),{success:!0}}catch(e){return console.error("Error banning user:",e),{success:!1,error:e.message}}},async unbanUser(e,t=!1){requireAdmin();try{const r=await getDoc(doc(usersRef,e));if(!r.exists())return{success:!1,error:"User not found"};const s=r.data();if(await updateDoc(doc(usersRef,e),{banned:!1,bannedAt:null,bannedReason:null}),t&&s.deviceFingerprints&&s.deviceFingerprints.length>0)for(const e of s.deviceFingerprints)try{await deleteDoc(doc(bannedDevicesRef,e))}catch(t){console.warn("Could not remove device ban:",e)}if(s.email){const e=s.email.toLowerCase().replace(/[.#$[\]]/g,"_");try{await deleteDoc(doc(bannedEmailsRef,e))}catch(e){console.warn("Could not remove email ban:",s.email)}}return await logAdminAction("user_unbanned",{targetUserId:e,targetUserEmail:s.email||null,targetUserName:s.displayName||null,deviceBansRemoved:t}),{success:!0}}catch(e){return console.error("Error unbanning user:",e),{success:!1,error:e.message}}},async checkUserBanned(e){try{const t=await getDoc(doc(usersRef,e));if(!t.exists())return{banned:!1};const r=t.data();return{banned:!0===r.banned,reason:r.bannedReason||null,bannedAt:r.bannedAt||null}}catch(e){return console.error("Error checking ban status:",e),{banned:!1}}},async checkDeviceBanned(e){try{const t=await getDoc(doc(bannedDevicesRef,e));return t.exists()?{banned:!0,reason:t.data().reason||null,bannedAt:t.data().bannedAt||null}:{banned:!1}}catch(e){return console.error("Error checking device ban:",e),{banned:!1}}},async storeDeviceFingerprint(e,t){try{return await updateDoc(doc(usersRef,e),{deviceFingerprints:arrayUnion(t)}),{success:!0}}catch(e){return console.error("Error storing device fingerprint:",e),{success:!1}}},async getWaitlist(){requireAdmin();try{const e=await getDocs(waitlistRef),t=[];for(const r of e.docs){const e=r.data();t.push({id:r.id,uid:e.uid,email:e.email||"Unknown",displayName:e.displayName||"Anonymous",photoURL:e.photoURL||null,status:e.status||"pending",joinedAt:e.joinedAt,approvedAt:e.approvedAt||null,rejectedAt:e.rejectedAt||null,deviceFingerprint:e.deviceFingerprint||null})}return t}catch(e){return console.error("Error fetching waitlist:",e),[]}},async updateWaitlistStatus(e,t){requireAdmin();try{const r={status:t};"approved"===t?r.approvedAt=(new Date).toISOString():"rejected"===t&&(r.rejectedAt=(new Date).toISOString()),await updateDoc(doc(waitlistRef,e),r);const s=await getDoc(doc(waitlistRef,e)),a=s.exists()?s.data():{};return await logAdminAction("waitlist_"+t,{targetUserId:e,targetUserEmail:a.email||null,targetUserName:a.displayName||null}),{success:!0}}catch(e){return console.error("Error updating waitlist status:",e),{success:!1,error:e.message}}},async deleteWaitlistEntry(e){requireAdmin();try{return await deleteDoc(doc(waitlistRef,e)),{success:!0}}catch(e){return console.error("Error deleting waitlist entry:",e),{success:!1,error:e.message}}},async getUserCards(e){try{const t=collection(db,"mulon_users",e,"card_inventory"),r=query(t,where("hasCard","==",!0)),s=await getDocs(r),a=[];return s.forEach((e=>{a.push({docId:e.id,...e.data()})})),console.log(`Loaded ${a.length} cards for user ${e} from subcollection`),a}catch(e){return console.error("Error fetching user cards:",e),[]}}};window.MulonData=MulonData;export{MulonData,OrderBook,Auth,UserData,OnboardingState,OverUnderSync,db,auth,marketsRef,categoriesRef,suggestionsRef,positionsRef,tradesRef,waitlistRef};
