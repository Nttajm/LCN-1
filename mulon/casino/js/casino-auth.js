import{initializeApp as e}from"https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";import{getFirestore as t,doc as s,setDoc as a,getDoc as n,updateDoc as r,increment as o,collection as i,addDoc as c,getDocs as u,query as l,where as d,serverTimestamp as h}from"https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";import{getAuth as g,signInWithPopup as m,signOut as b,GoogleAuthProvider as w,onAuthStateChanged as y}from"https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";import{checkMaintenanceAccess as f,MAINTENANCE_MODE as p}from"../../js/maintenance.js";const C=e({apiKey:"AIzaSyAGcg43F94bWqUuyLH-AjghrAfduEVQ8ZM",authDomain:"overunder-ths.firebaseapp.com",projectId:"overunder-ths",storageBucket:"overunder-ths.firebasestorage.app",messagingSenderId:"690530120785",appId:"1:690530120785:web:36dc297cb517ac76cb7470",measurementId:"G-Q30T39R8VY"}),A=t(C),S=g(C),v=new w,D=i(A,"mulon_banned_devices"),U=i(A,"mulon_banned_emails");window.checkBanStatus=async function(){try{const e=S.currentUser,t=function(){let e=0;const t=[navigator.userAgent,navigator.language,screen.width+"x"+screen.height,screen.colorDepth,(new Date).getTimezoneOffset(),navigator.hardwareConcurrency||"unknown",navigator.platform].join("|");for(let s=0;s<t.length;s++)e=(e<<5)-e+t.charCodeAt(s),e&=e;let s=localStorage.getItem("mulon_device_id");return s||(s="dev_"+Date.now()+"_"+Math.random().toString(36).substring(2,15),localStorage.setItem("mulon_device_id",s)),s+"_"+Math.abs(e).toString(36)}();if((await n(s(D,t))).exists())return console.log("Device is banned, redirecting..."),window.location.href="https://parismou.org/PMoU-Procedures/Library/banning",!0;if(e){if(e.email){const t=e.email.toLowerCase().replace(/[.#$[\]]/g,"_");if((await n(s(U,t))).exists())return console.log("Email is banned, redirecting..."),window.location.href="https://parismou.org/PMoU-Procedures/Library/banning",!0}const t=await n(s(A,"mulon_users",e.uid));if(t.exists()&&!0===t.data().banned)return console.log("User is banned, redirecting..."),window.location.href="https://parismou.org/PMoU-Procedures/Library/banning",!0}return!1}catch(e){return console.error("Error checking ban status:",e),!1}};const k={tabId:null,lastKnownBalance:null,lastSyncTime:0,syncInterval:null,balanceVersion:0,init(){this.tabId="tab_"+Date.now()+"_"+Math.random().toString(36).substring(2,9),window.addEventListener("storage",(e=>this.handleStorageEvent(e))),document.addEventListener("visibilitychange",(()=>this.handleVisibilityChange())),window.addEventListener("beforeunload",(()=>this.cleanup())),this.registerTab(),this.syncInterval=setInterval((()=>this.checkSync()),2e3),console.log("TabSync initialized:",this.tabId)},registerTab(){try{const e=this.getActiveTabs();e[this.tabId]={openedAt:Date.now(),lastActivity:Date.now(),page:window.location.pathname},localStorage.setItem("casino_active_tabs",JSON.stringify(e))}catch(e){console.error("TabSync registerTab error:",e)}},getActiveTabs(){try{const e=localStorage.getItem("casino_active_tabs");if(!e)return{};const t=JSON.parse(e),s=Date.now(),a={};for(const[e,n]of Object.entries(t))s-n.lastActivity<3e4&&(a[e]=n);return a}catch(e){return{}}},updateActivity(){try{const e=this.getActiveTabs();e[this.tabId]&&(e[this.tabId].lastActivity=Date.now(),localStorage.setItem("casino_active_tabs",JSON.stringify(e)))}catch(e){console.error("TabSync updateActivity error:",e)}},broadcastBalanceUpdate(e,t="unknown"){try{this.balanceVersion++;const s={balance:e,version:this.balanceVersion,sourceTab:this.tabId,source:t,timestamp:Date.now()};localStorage.setItem("casino_balance_update",JSON.stringify(s)),this.lastKnownBalance=e,this.lastSyncTime=Date.now(),console.log(`TabSync: Broadcasted balance update $${e} (v${this.balanceVersion}) from ${t}`)}catch(e){console.error("TabSync broadcastBalanceUpdate error:",e)}},handleStorageEvent(e){if("casino_balance_update"===e.key&&e.newValue)try{const t=JSON.parse(e.newValue);if(t.sourceTab===this.tabId)return;if(CasinoAuth.userData&&void 0!==t.balance){const e=CasinoAuth.userData.balance;CasinoAuth.userData.balance=t.balance,this.lastKnownBalance=t.balance,this.lastSyncTime=Date.now(),console.log(`TabSync: Received balance update from another tab: $${e} -> $${t.balance}`),window.dispatchEvent(new CustomEvent("balanceUpdated",{detail:{balance:t.balance,source:"otherTab",oldBalance:e}}))}}catch(e){console.error("TabSync handleStorageEvent error:",e)}if("casino_force_refresh"===e.key&&e.newValue)try{JSON.parse(e.newValue).sourceTab!==this.tabId&&(console.log("TabSync: Force refresh signal received, reloading balance..."),this.forceRefreshBalance())}catch(e){console.error("TabSync force refresh error:",e)}},async handleVisibilityChange(){"visible"===document.visibilityState&&(console.log("TabSync: Tab became visible, syncing balance..."),await this.forceRefreshBalance(),this.updateActivity())},async forceRefreshBalance(){if(!CasinoAuth.currentUser)return null;try{const e=await n(s(A,"mulon_users",CasinoAuth.currentUser.uid));if(e.exists()){const t=e.data(),s=CasinoAuth.userData?.balance;return CasinoAuth.userData.balance=t.balance,CasinoAuth.userData.keys=t.keys,CasinoAuth.userData.xps=t.xps,CasinoAuth.userData.plinkoBalls=t.plinkoBalls,this.lastKnownBalance=t.balance,this.lastSyncTime=Date.now(),s!==t.balance&&(console.log(`TabSync: Balance synced from server: $${s} -> $${t.balance}`),window.dispatchEvent(new CustomEvent("balanceUpdated",{detail:{balance:t.balance,source:"server",oldBalance:s}}))),t.balance}}catch(e){console.error("TabSync forceRefreshBalance error:",e)}return null},isBalanceStale(){return Date.now()-this.lastSyncTime>5e3},async checkSync(){this.updateActivity(),"visible"===document.visibilityState&&this.isBalanceStale()&&await this.forceRefreshBalance()},getActiveTabCount(){return Object.keys(this.getActiveTabs()).length},cleanup(){try{const e=this.getActiveTabs();delete e[this.tabId],localStorage.setItem("casino_active_tabs",JSON.stringify(e)),this.syncInterval&&clearInterval(this.syncInterval)}catch(e){console.error("TabSync cleanup error:",e)}}};window.TabSync=k;const B={isOnline:navigator.onLine,checkInterval:null,pendingBets:[],gameDisabled:!1,start(){this.isOnline=navigator.onLine,window.addEventListener("online",(()=>this.handleOnline())),window.addEventListener("offline",(()=>this.handleOffline())),this.checkInterval=setInterval((()=>this.pingServer()),3e3),this.pingServer()},async pingServer(){try{const e=new AbortController,t=setTimeout((()=>e.abort()),2e3);await fetch("https://firestore.googleapis.com/google.firestore.v1.Firestore",{method:"HEAD",mode:"no-cors",cache:"no-store",signal:e.signal}),clearTimeout(t),this.isOnline||this.handleOnline(),this.isOnline=!0}catch(e){this.isOnline&&this.handleOffline(),this.isOnline=!1}},handleOffline(){if(console.warn("ConnectionMonitor: Connection lost - disabling game"),this.isOnline=!1,this.gameDisabled=!0,CasinoAuth.userData){const e={timestamp:Date.now(),balance:CasinoAuth.userData.balance,keys:CasinoAuth.userData.keys||0};localStorage.setItem("casino_disconnect_pending",JSON.stringify(e))}},async handleOnline(){console.log("ConnectionMonitor: Connection restored"),this.isOnline=!0,await this.applyDisconnectPenalty(),this.gameDisabled=!1},async applyDisconnectPenalty(){const e=localStorage.getItem("casino_disconnect_pending");if(e){try{const t=JSON.parse(e),a=Date.now()-t.timestamp;if(a>5e3&&CasinoAuth.currentUser&&CasinoAuth.userData){const e=Math.ceil(a/6e4),n=Math.min(.5,.05*e),i=Math.floor(t.balance*n*100)/100;if(i>0){console.warn(`ConnectionMonitor: Applying disconnect penalty of $${i}`);const e=CasinoAuth.currentUser.uid;await r(s(A,"mulon_users",e),{balance:o(-i),"casinoStats.disconnectPenalties":o(i)}),CasinoAuth.userData.balance=Math.max(0,CasinoAuth.userData.balance-i)}}}catch(e){console.error("Error applying disconnect penalty:",e)}localStorage.removeItem("casino_disconnect_pending")}},canPlay(){return this.isOnline&&!this.gameDisabled},requireConnection(){if(!this.isOnline||this.gameDisabled)throw new Error("NO_CONNECTION");return!0},stop(){this.checkInterval&&(clearInterval(this.checkInterval),this.checkInterval=null)}};window.ConnectionMonitor=B;export const CasinoAuth={currentUser:null,userData:null,authStateListeners:[],init(){return k.init(),new Promise((e=>{y(S,(async t=>{if("function"==typeof window.checkBanStatus){if(await window.checkBanStatus())return void e(null)}t?(this.currentUser={uid:t.uid,email:t.email,displayName:t.displayName,photoURL:t.photoURL},await this.loadUserData(t.uid),k.lastKnownBalance=this.userData?.balance,k.lastSyncTime=Date.now(),console.log("Casino: User signed in:",t.displayName)):(this.currentUser=null,this.userData=null,console.log("Casino: No user signed in")),this.authStateListeners.forEach((e=>e(this.currentUser,this.userData))),e(this.currentUser)}))}))},async initWithMaintenanceCheck(){if("function"==typeof window.checkBanStatus){if(await window.checkBanStatus())return!1}if(B.start(),await B.applyDisconnectPenalty(),await this.init(),p){return await f({getUser:()=>this.currentUser,redirectUrl:"../maintenance.html",delay:500})}return!0},getUser(){return this.currentUser},async loadUserData(e){try{const t=await n(s(A,"mulon_users",e));t.exists()?this.userData=t.data():(this.userData={balance:500,xps:0,keys:40,plinkoBalls:45,winStreak:0,xpChestsClaimed:0,casinoStats:{totalWagered:0,totalWon:0,gamesPlayed:0},xpStats:{totalEarned:0,totalSpent:0,bestStreak:0},createdAt:(new Date).toISOString(),lastLoginAt:h()},await a(s(A,"mulon_users",e),this.userData)),await r(s(A,"mulon_users",e),{lastLoginAt:h()});const o=await n(s(A,"mulon_users",e));o.exists()&&(this.userData=o.data())}catch(e){console.error("Error loading user data:",e),this.userData={balance:500,xps:0,winStreak:0}}return this.userData},async signIn(){try{return{success:!0,user:(await m(S,v)).user}}catch(e){return console.error("Sign in error:",e),{success:!1,error:e.message}}},async signOut(){try{return await b(S),{success:!0}}catch(e){return console.error("Sign out error:",e),{success:!1,error:e.message}}},isSignedIn(){return null!==this.currentUser},getBalance(){return this.userData?.balance??500},getKeys(){return this.userData?.keys??40},getPlinkoBalls(){return this.userData?.plinkoBalls??45},getXPs(){return this.userData?.xps??0},getWinStreak(){return this.userData?.winStreak??0},onAuthStateChange(e){this.authStateListeners.push(e),void 0!==this.currentUser&&e(this.currentUser,this.userData)}};export const CasinoDB={getDB:()=>A,async getServerBalance(){if(!CasinoAuth.currentUser)return null;try{const e=await n(s(A,"mulon_users",CasinoAuth.currentUser.uid));if(e.exists()){const t=e.data().balance;return CasinoAuth.userData.balance=t,k.lastKnownBalance=t,k.lastSyncTime=Date.now(),t}}catch(e){console.error("Error getting server balance:",e)}return null},async safePlaceBet(e,t){if(!CasinoAuth.currentUser)return{success:!1,error:"Not signed in"};if(!B.canPlay())return{success:!1,error:"Connection lost - cannot place bet"};try{const a=await this.getServerBalance();if(null===a)return{success:!1,error:"Could not verify balance. Please refresh."};if(a<e)return window.dispatchEvent(new CustomEvent("balanceUpdated",{detail:{balance:a,source:"server"}})),{success:!1,error:`Insufficient balance! You have $${a.toFixed(2)}`};const n=CasinoAuth.currentUser.uid,i=Math.round(100*(a-e))/100;return await r(s(A,"mulon_users",n),{balance:i,"casinoStats.totalWagered":o(e),"casinoStats.gamesPlayed":o(1)}),CasinoAuth.userData.balance=i,k.broadcastBalanceUpdate(i,`bet_${t}`),window.dispatchEvent(new CustomEvent("balanceUpdated",{detail:{balance:i,source:"bet"}})),{success:!0,newBalance:i,previousBalance:a}}catch(e){return console.error("Error in safePlaceBet:",e),{success:!1,error:e.message}}},async safeRecordWin(e,t){if(!CasinoAuth.currentUser)return{success:!1,error:"Not signed in"};if(!B.canPlay())return{success:!1,error:"Connection lost - win not recorded"};try{const a=CasinoAuth.currentUser.uid;await r(s(A,"mulon_users",a),{balance:o(e),"casinoStats.totalWon":o(e)});const n=await this.getServerBalance();return k.broadcastBalanceUpdate(n,`win_${t}`),window.dispatchEvent(new CustomEvent("balanceUpdated",{detail:{balance:n,source:"win"}})),{success:!0,newBalance:n,winAmount:e}}catch(e){return console.error("Error in safeRecordWin:",e),{success:!1,error:e.message}}},async safeGameRound(e,t,a){if(!CasinoAuth.currentUser)return{success:!1,error:"Not signed in"};if(!B.canPlay())return{success:!1,error:"Connection lost - cannot play"};try{const n=await this.getServerBalance();if(null===n)return{success:!1,error:"Could not verify balance. Please refresh."};if(n<e)return window.dispatchEvent(new CustomEvent("balanceUpdated",{detail:{balance:n,source:"server"}})),{success:!1,error:`Insufficient balance! You have $${n.toFixed(2)}`};const i=CasinoAuth.currentUser.uid,c=t-e,u=Math.round(100*(n+c))/100,l={balance:u,"casinoStats.totalWagered":o(e),"casinoStats.gamesPlayed":o(1)};return t>0&&(l["casinoStats.totalWon"]=o(t)),await r(s(A,"mulon_users",i),l),CasinoAuth.userData.balance=u,k.broadcastBalanceUpdate(u,`round_${a}`),window.dispatchEvent(new CustomEvent("balanceUpdated",{detail:{balance:u,source:"gameRound",netChange:c}})),this.activeSessionId&&await this.updateGameSession({bet:e,won:t}),{success:!0,newBalance:u,previousBalance:n,netChange:c,isWin:c>0}}catch(e){return console.error("Error in safeGameRound:",e),{success:!1,error:e.message}}},async updateBalance(e){if(!CasinoAuth.currentUser)return console.warn("Cannot update balance: Not signed in"),null;if(!B.canPlay())return console.warn("Cannot update balance: No connection"),null;try{const t=CasinoAuth.currentUser.uid,a=await this.getServerBalance();if(null===a)return console.warn("Cannot update balance: Could not get server balance"),null;const n=Math.max(0,Math.round(100*(a+e))/100);return await r(s(A,"mulon_users",t),{balance:n}),CasinoAuth.userData.balance=n,k.broadcastBalanceUpdate(n,"updateBalance"),n}catch(e){return console.error("Error updating balance:",e),null}},async placeBet(e,t){if(!CasinoAuth.currentUser)return{success:!1,error:"Not signed in"};if(!B.canPlay())return{success:!1,error:"Connection lost - cannot place bet"};const a=await this.getServerBalance();if(null===a)return{success:!1,error:"Could not verify balance. Please refresh."};if(a<e)return{success:!1,error:`Insufficient balance! You have $${a.toFixed(2)}`};try{this.activeSessionId||await this.startGameSession(t,e);const n=CasinoAuth.currentUser.uid,i=Math.round(100*(a-e))/100;return await r(s(A,"mulon_users",n),{balance:i,"casinoStats.totalWagered":o(e),"casinoStats.gamesPlayed":o(1)}),CasinoAuth.userData.balance=i,k.broadcastBalanceUpdate(i,`placeBet_${t}`),{success:!0,newBalance:i}}catch(e){return console.error("Error placing bet:",e),{success:!1,error:e.message}}},async recordWin(e,t=0){if(!CasinoAuth.currentUser)return{success:!1,error:"Not signed in"};if(!B.canPlay())return{success:!1,error:"Connection lost - win not recorded"};try{const a=CasinoAuth.currentUser.uid;await r(s(A,"mulon_users",a),{balance:o(e),"casinoStats.totalWon":o(e)});const n=await this.getServerBalance();return k.broadcastBalanceUpdate(n,"recordWin"),this.activeSessionId&&t>0&&await this.updateGameSession({bet:t,won:e}),{success:!0,newBalance:n}}catch(e){return console.error("Error recording win:",e),{success:!1,error:e.message}}},async recordGameResult(e,t,s){if(!CasinoAuth.currentUser)return{success:!1,error:"Not signed in"};if(!B.canPlay())return{success:!1,error:"Connection lost - result not recorded"};try{return this.activeSessionId||await this.startGameSession(e,t),this.activeSessionId&&await this.updateGameSession({bet:t,won:s}),{success:!0}}catch(e){return console.error("Error recording game result:",e),{success:!1,error:e.message}}},async recordLoss(e){if(!CasinoAuth.currentUser)return{success:!1,error:"Not signed in"};try{const e=CasinoAuth.currentUser.uid,t=CasinoAuth.userData.keys??30,a=Math.max(0,t-1);return await r(s(A,"mulon_users",e),{keys:a}),CasinoAuth.userData.keys=a,{success:!0,newKeys:a}}catch(e){return console.error("Error recording loss:",e),{success:!1,error:e.message}}},async usePlinkoBall(){if(!CasinoAuth.currentUser)return{success:!1,error:"Not signed in"};try{const e=CasinoAuth.currentUser.uid;let t=CasinoAuth.userData.plinkoBalls??45,a=CasinoAuth.userData.keys??30;if(t<=0){if(a<=0)return{success:!1,error:"No keys left! Come back tomorrow for free keys."};a-=1,t=45}const n=t-1;return await r(s(A,"mulon_users",e),{plinkoBalls:n,keys:a}),CasinoAuth.userData.plinkoBalls=n,CasinoAuth.userData.keys=a,{success:!0,ballsLeft:n,keysLeft:a}}catch(e){return console.error("Error using plinko ball:",e),{success:!1,error:e.message}}},async refreshBalance(){if(!CasinoAuth.currentUser)return null;try{const e=await n(s(A,"mulon_users",CasinoAuth.currentUser.uid));if(e.exists())return CasinoAuth.userData.balance=e.data().balance,CasinoAuth.userData.plinkoBalls=e.data().plinkoBalls??45,CasinoAuth.userData.balance}catch(e){console.error("Error refreshing balance:",e)}return null},async setPendingPlinkoBalls(e){if(CasinoAuth.currentUser)try{const t=CasinoAuth.currentUser.uid;await r(s(A,"mulon_users",t),{pendingPlinkoBalls:e}),CasinoAuth.userData.pendingPlinkoBalls=e}catch(e){console.error("Error setting pending balls:",e)}},getPendingPlinkoBalls:()=>CasinoAuth.userData?.pendingPlinkoBalls??0,async checkRefreshPenalty(){if(!CasinoAuth.currentUser)return{penalty:0};try{const e=CasinoAuth.currentUser.uid,t=await n(s(A,"mulon_users",e));if(t.exists()){const a=t.data().pendingPlinkoBalls??0;if(a>0){const n=t.data().balance??0,o=.1*a,i=Math.round(n*o*100)/100,c=Math.max(0,n-i);return await r(s(A,"mulon_users",e),{balance:c,pendingPlinkoBalls:0}),CasinoAuth.userData.balance=c,CasinoAuth.userData.pendingPlinkoBalls=0,{penalty:i,ballsLost:a}}}}catch(e){console.error("Error checking refresh penalty:",e)}return{penalty:0,ballsLost:0}},async setPendingRouletteSpin(e){if(CasinoAuth.currentUser)try{const t=CasinoAuth.currentUser.uid;await r(s(A,"mulon_users",t),{pendingRouletteSpin:e}),CasinoAuth.userData.pendingRouletteSpin=e}catch(e){console.error("Error setting pending roulette spin:",e)}},getPendingRouletteSpin:()=>CasinoAuth.userData?.pendingRouletteSpin??0,async checkRouletteRefreshPenalty(){if(!CasinoAuth.currentUser)return{penalty:0};try{const e=CasinoAuth.currentUser.uid,t=await n(s(A,"mulon_users",e));if(t.exists()){const a=t.data().pendingRouletteSpin??0;if(a>0){const n=t.data().balance??0,o=a,i=Math.max(0,n-o);return await r(s(A,"mulon_users",e),{balance:i,pendingRouletteSpin:0}),CasinoAuth.userData.balance=i,CasinoAuth.userData.pendingRouletteSpin=0,{penalty:o}}}}catch(e){console.error("Error checking roulette refresh penalty:",e)}return{penalty:0}},async awardXPs(e,t,a){if(!CasinoAuth.currentUser)return console.log("awardXPs: Not signed in"),{success:!1,error:"Not signed in"};try{const a=CasinoAuth.currentUser.uid,n=CasinoAuth.userData?.xps??0,i=CasinoAuth.userData?.winStreak??0;let c=1;if(t>=2)switch(e){case"plinko":c=t>=100?50:t>=20?20:t>=10?10:t>=5?5:2;break;case"gems":c=t>=10?25:t>=5?12:t>=3?6:3;break;case"dragon-tower":c=t>=50?100:t>=20?40:t>=10?20:t>=5?10:4;break;case"crash":c=t>=100?75:t>=50?40:t>=20?25:t>=10?15:t>=5?8:t>=2.1?3:1;break;default:c=Math.max(1,Math.floor(t))}const u=Math.min(8,Math.pow(1.5,i)),l=Math.round(c*u),d=i+1,h=n+l,g=CasinoAuth.userData?.xpStats?.bestStreak??0;return console.log(`awardXPs: base=${c}, streak=${i}, mult=${u}, earned=${l}`),await r(s(A,"mulon_users",a),{xps:h,winStreak:d,"xpStats.totalEarned":o(l),"xpStats.bestStreak":d>g?d:g}),CasinoAuth.userData.xps=h,CasinoAuth.userData.winStreak=d,CasinoAuth.userData.xpStats||(CasinoAuth.userData.xpStats={}),CasinoAuth.userData.xpStats.bestStreak=Math.max(g,d),{success:!0,xpsEarned:l,totalXPs:h,streak:d,streakMultiplier:u}}catch(e){return console.error("Error awarding xps:",e),{success:!1,error:e.message}}},async resetStreak(){if(!CasinoAuth.currentUser)return{success:!1,error:"Not signed in"};try{const e=CasinoAuth.currentUser.uid;return(CasinoAuth.userData?.winStreak??0)>0&&(await r(s(A,"mulon_users",e),{winStreak:0}),CasinoAuth.userData.winStreak=0),{success:!0,streak:0}}catch(e){return console.error("Error resetting streak:",e),{success:!1,error:e.message}}},async useXPs(e){if(!CasinoAuth.currentUser)return{success:!1,error:"Not signed in"};const t=CasinoAuth.userData?.xps??0;if(t<e)return{success:!1,error:"Insufficient xps!"};try{const a=CasinoAuth.currentUser.uid,n=t-e;return await r(s(A,"mulon_users",a),{xps:n,"xpStats.totalSpent":o(e)}),CasinoAuth.userData.xps=n,{success:!0,newXPs:n}}catch(e){return console.error("Error using xps:",e),{success:!1,error:e.message}}},async saveCard(e){if(!CasinoAuth.currentUser)return console.log("saveCard: Not signed in"),{success:!1,error:"Not signed in"};try{const t=CasinoAuth.currentUser.uid,s=i(A,"mulon_users",t,"cards"),a=await c(s,{cardNumber:e,hasCard:!0,obtainedAt:h(),obtainedFrom:"chest",tradedFrom:null});return console.log(`Card ${e} saved with doc ID: ${a.id}. Collection: users/${t}/cards`),{success:!0,cardDocId:a.id}}catch(e){return console.error("Error saving card:",e),{success:!1,error:e.message}}},async getCards(e=null){const t=e||CasinoAuth.currentUser?.uid;if(!t)return[];try{const e=i(A,"mulon_users",t,"cards"),s=l(e,d("hasCard","==",!0)),a=await u(s),n=[];return a.forEach((e=>{n.push({docId:e.id,...e.data()})})),n}catch(e){return console.error("Error getting cards:",e),[]}},async getAllCards(e=null){const t=e||CasinoAuth.currentUser?.uid;if(!t)return[];try{const e=i(A,"mulon_users",t,"cards"),s=await u(e),a=[];return s.forEach((e=>{a.push({docId:e.id,...e.data()})})),a}catch(e){return console.error("Error getting all cards:",e),[]}},async markCardTraded(e){if(!CasinoAuth.currentUser)return{success:!1,error:"Not signed in"};try{const t=CasinoAuth.currentUser.uid,a=s(A,"mulon_users",t,"cards",e);return await r(a,{hasCard:!1,tradedAt:h()}),{success:!0}}catch(e){return console.error("Error marking card as traded:",e),{success:!1,error:e.message}}},async transferCard(e,t,s,a=null){try{const n=i(A,"mulon_users",s,"cards"),r=await c(n,{cardNumber:e,hasCard:!0,obtainedAt:h(),obtainedFrom:"trade",tradedFrom:t,tradeId:a});return console.log(`Card ${e} transferred from ${t} to ${s}, new doc: ${r.id}`),{success:!0,newCardDocId:r.id}}catch(e){return console.error("Error transferring card:",e),{success:!1,error:e.message}}},async purchaseChest(e){if(!CasinoAuth.currentUser)return{success:!1,error:"Not signed in"};const t={uncommon:250,epic:1267}[e];if(!t)return{success:!1,error:"Invalid chest type"};if(CasinoAuth.userData.balance<t)return{success:!1,error:`Insufficient balance! Need $${t}`};try{const e=CasinoAuth.currentUser.uid,a=Math.round(100*(CasinoAuth.userData.balance-t))/100;return await r(s(A,"mulon_users",e),{balance:a}),CasinoAuth.userData.balance=a,{success:!0,newBalance:a,cost:t}}catch(e){return console.error("Error purchasing chest:",e),{success:!1,error:e.message}}},async claimXpChest(){if(!CasinoAuth.currentUser)return{success:!1,error:"Not signed in"};try{const e=CasinoAuth.currentUser.uid,t=CasinoAuth.userData.xps||0,a=CasinoAuth.userData.xpChestsClaimed||0,n=Math.floor(t/100)-a;if(n<=0)return{success:!1,error:"No XP chests available"};const o=a+1;return await r(s(A,"mulon_users",e),{xpChestsClaimed:o}),CasinoAuth.userData.xpChestsClaimed=o,{success:!0,chestsClaimed:o,chestsRemaining:n-1}}catch(e){return console.error("Error claiming XP chest:",e),{success:!1,error:e.message}}},getXpChestsClaimed:()=>CasinoAuth.userData?.xpChestsClaimed||0,getAvailableXpChests(){const e=CasinoAuth.userData?.xps||0,t=CasinoAuth.userData?.xpChestsClaimed||0,s=Math.floor(e/100);return Math.max(0,s-t)},async getUser(e){try{const t=await n(s(A,"mulon_users",e));return t.exists()?t.data():null}catch(e){return console.error("Error getting user:",e),null}},async getOnlineUsersCount(e=15){try{const t=new Date(Date.now()-60*e*1e3),s=i(A,"mulon_users"),a=l(s,d("lastLoginAt",">=",t)),n=await u(a);return console.log(`Found ${n.size} users active in last ${e} minutes`),n.size}catch(e){return console.error("Error getting online users:",e),Math.floor(30*Math.random())+10}},async updateLastActivity(){if(CasinoAuth.currentUser)try{const e=CasinoAuth.currentUser.uid;await r(s(A,"mulon_users",e),{lastLoginAt:h()}),console.log("Updated last activity for user:",e)}catch(e){console.error("Error updating last activity:",e)}},activeSessionId:null,async startGameSession(e,t=0){if(!CasinoAuth.currentUser)return console.log("startGameSession: Not signed in"),{success:!1,error:"Not signed in"};try{const s=CasinoAuth.currentUser.uid,a=i(A,"mulon_users",s,"sessions"),n={gameName:e,startedAt:h(),lastActivityAt:h(),endedAt:null,status:"active",totalBets:0,totalWagered:0,totalWon:0,netProfit:0,gamesPlayed:0,wins:0,losses:0,initialBalance:CasinoAuth.userData?.balance||0,finalBalance:null,initialBet:t,biggestWin:0,biggestLoss:0,longestWinStreak:0,currentWinStreak:0,userAgent:navigator.userAgent,screenResolution:`${window.screen.width}x${window.screen.height}`,timezone:Intl.DateTimeFormat().resolvedOptions().timeZone},r=await c(a,n);return this.activeSessionId=r.id,console.log(`Started ${e} session: ${r.id}`),{success:!0,sessionId:r.id,session:n}}catch(e){return console.error("Error starting game session:",e),{success:!1,error:e.message}}},async updateGameSession(e){if(!CasinoAuth.currentUser||!this.activeSessionId)return console.log("updateGameSession: No active session"),{success:!1,error:"No active session"};try{const t=CasinoAuth.currentUser.uid,a=s(A,"mulon_users",t,"sessions",this.activeSessionId),i=await n(a);if(!i.exists())return console.error("Session document not found"),{success:!1,error:"Session not found"};const c=i.data(),u=e.won>e.bet,l=e.won-e.bet,d=u?(c.currentWinStreak||0)+1:0,g={lastActivityAt:h(),totalBets:o(1),totalWagered:o(e.bet),totalWon:o(e.won),netProfit:o(l),gamesPlayed:o(1),wins:u?o(1):c.wins||0,losses:u?c.losses||0:o(1),currentWinStreak:d,longestWinStreak:Math.max(c.longestWinStreak||0,d),biggestWin:Math.max(c.biggestWin||0,e.won),biggestLoss:Math.max(c.biggestLoss||0,e.bet)};return await r(a,g),console.log(`Updated session ${this.activeSessionId}: ${u?"WIN":"LOSS"} $${l.toFixed(2)}`),{success:!0,sessionId:this.activeSessionId}}catch(e){return console.error("Error updating game session:",e),{success:!1,error:e.message}}},async endGameSession(e="user_ended"){if(!CasinoAuth.currentUser||!this.activeSessionId)return console.log("endGameSession: No active session"),{success:!1,error:"No active session"};try{const t=CasinoAuth.currentUser.uid,a=s(A,"mulon_users",t,"sessions",this.activeSessionId);await r(a,{endedAt:h(),status:"abandoned"===e?"abandoned":"ended",finalBalance:CasinoAuth.userData?.balance||0,endReason:e}),console.log(`Ended session ${this.activeSessionId}: ${e}`);const n=this.activeSessionId;return this.activeSessionId=null,{success:!0,sessionId:n}}catch(e){return console.error("Error ending game session:",e),{success:!1,error:e.message}}},async updateSessionActivity(){if(!CasinoAuth.currentUser||!this.activeSessionId)return{success:!1,error:"No active session"};try{const e=CasinoAuth.currentUser.uid,t=s(A,"mulon_users",e,"sessions",this.activeSessionId);return await r(t,{lastActivityAt:h()}),{success:!0}}catch(e){return console.error("Error updating session activity:",e),{success:!1,error:e.message}}},async getGameSessions(e={}){const t=e.userId||CasinoAuth.currentUser?.uid;if(!t)return[];try{let s=i(A,"mulon_users",t,"sessions");e.gameName&&(s=l(s,d("gameName","==",e.gameName))),e.status&&(s=l(s,d("status","==",e.status)));const a=await u(s),n=[];return a.forEach((e=>{n.push({id:e.id,...e.data()})})),n.sort(((e,t)=>{const s=e.startedAt?.toMillis?.()||0;return(t.startedAt?.toMillis?.()||0)-s})),n}catch(e){return console.error("Error getting game sessions:",e),[]}},async getSessionStats(e=null){const t=e||CasinoAuth.currentUser?.uid;if(!t)return null;try{const e=await this.getGameSessions({userId:t}),s={totalSessions:e.length,activeSessions:e.filter((e=>"active"===e.status)).length,totalGamesPlayed:0,totalWagered:0,totalWon:0,netProfit:0,winRate:0,avgSessionDuration:0,favoriteGame:null,gameBreakdown:{}},a={};let n=0,r=0;if(e.forEach((e=>{if(s.totalGamesPlayed+=e.gamesPlayed||0,s.totalWagered+=e.totalWagered||0,s.totalWon+=e.totalWon||0,s.netProfit+=e.netProfit||0,a[e.gameName]=(a[e.gameName]||0)+1,e.startedAt&&e.endedAt){const t=e.endedAt.toMillis()-e.startedAt.toMillis();n+=t,r++}s.gameBreakdown[e.gameName]||(s.gameBreakdown[e.gameName]={sessions:0,gamesPlayed:0,totalWagered:0,totalWon:0,netProfit:0}),s.gameBreakdown[e.gameName].sessions++,s.gameBreakdown[e.gameName].gamesPlayed+=e.gamesPlayed||0,s.gameBreakdown[e.gameName].totalWagered+=e.totalWagered||0,s.gameBreakdown[e.gameName].totalWon+=e.totalWon||0,s.gameBreakdown[e.gameName].netProfit+=e.netProfit||0})),s.totalGamesPlayed>0){const t=e.reduce(((e,t)=>e+(t.wins||0)),0);s.winRate=t/s.totalGamesPlayed*100}r>0&&(s.avgSessionDuration=n/r);let o=0;for(const[e,t]of Object.entries(a))t>o&&(o=t,s.favoriteGame=e);return s}catch(e){return console.error("Error getting session stats:",e),null}},async checkAbandonedSessions(){if(CasinoAuth.currentUser)try{const e=CasinoAuth.currentUser.uid,t=await this.getGameSessions({userId:e,status:"active"}),a=Date.now()-18e5;for(const n of t){if((n.lastActivityAt?.toMillis?.()||0)<a){const t=s(A,"mulon_users",e,"sessions",n.id);await r(t,{status:"abandoned",endedAt:h(),endReason:"auto_abandoned",finalBalance:CasinoAuth.userData?.balance||0}),console.log(`Marked session ${n.id} as abandoned`)}}}catch(e){console.error("Error checking abandoned sessions:",e)}}};window.CasinoAuth=CasinoAuth,window.CasinoDB=CasinoDB,window.TabSync=k;export{k as TabSync};